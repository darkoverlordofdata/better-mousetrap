/* demo.c generated by valac 0.34.7, the Vala compiler
 * generated from demo.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <emscripten.h>


#define TYPE_CONTEXT (context_get_type ())
typedef struct _Context Context;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))

struct _Context {
	gdouble mark1;
	gdouble mark2;
	gdouble delta;
};


extern SDL_Surface* surface;
SDL_Surface* surface = NULL;
extern SDL_Surface* bgd;
SDL_Surface* bgd = NULL;
extern gdouble mark1;
gdouble mark1 = 0.0;
extern gdouble mark2;
gdouble mark2 = 0.0;
extern gdouble delta;
gdouble delta = 0.0;

GType context_get_type (void) G_GNUC_CONST;
Context* context_dup (const Context* self);
void context_free (Context* self);
void _vala_main (gchar** args, int args_length1);
void main_loop (void* arg);
static void _main_loop_em_arg_callback_func (void* arg);


Context* context_dup (const Context* self) {
	Context* dup;
	dup = g_new0 (Context, 1);
	memcpy (dup, self, sizeof (Context));
	return dup;
}


void context_free (Context* self) {
	g_free (self);
}


GType context_get_type (void) {
	static volatile gsize context_type_id__volatile = 0;
	if (g_once_init_enter (&context_type_id__volatile)) {
		GType context_type_id;
		context_type_id = g_boxed_type_register_static ("Context", (GBoxedCopyFunc) context_dup, (GBoxedFreeFunc) context_free);
		g_once_init_leave (&context_type_id__volatile, context_type_id);
	}
	return context_type_id__volatile;
}


static void _main_loop_em_arg_callback_func (void* arg) {
	main_loop (arg);
}


void _vala_main (gchar** args, int args_length1) {
	gint _tmp0_ = 0;
	SDL_Surface* _tmp2_ = NULL;
	SDL_Surface* _tmp3_ = NULL;
	SDL_Surface* _tmp5_ = NULL;
	SDL_Surface* _tmp6_ = NULL;
	Context ctx = {0};
	gdouble _tmp8_ = 0.0;
	Context _tmp9_ = {0};
	gdouble _tmp10_ = 0.0;
	_tmp0_ = SDL_Init ((guint32) SDL_INIT_VIDEO);
	if (_tmp0_ < 0) {
		const gchar* _tmp1_ = NULL;
		_tmp1_ = SDL_GetError ();
		g_print ("Unable to init SDL %s\n", _tmp1_);
		return;
	}
	_tmp2_ = SDL_SetVideoMode (800, 300, 32, (guint32) (SDL_HWSURFACE | SDL_DOUBLEBUF));
	surface = _tmp2_;
	_tmp3_ = surface;
	if (_tmp3_ == NULL) {
		const gchar* _tmp4_ = NULL;
		_tmp4_ = SDL_GetError ();
		g_print ("Unable to set video %s\n", _tmp4_);
		return;
	}
	_tmp5_ = SDL_LoadBMP ("assets/images/background.png");
	_SDL_FreeSurface0 (bgd);
	bgd = _tmp5_;
	_tmp6_ = bgd;
	if (_tmp6_ == NULL) {
		const gchar* _tmp7_ = NULL;
		_tmp7_ = SDL_GetError ();
		g_print ("Unable to load bpm %s\n", _tmp7_);
		return;
	}
	SDL_WM_SetCaption ("ShmupWarz", "ShmupWarz");
	_tmp8_ = emscripten_get_now ();
	_tmp9_.mark1 = _tmp8_ / 1000;
	_tmp9_.mark2 = (gdouble) 0;
	_tmp9_.delta = (gdouble) 0;
	ctx = _tmp9_;
	_tmp10_ = emscripten_get_now ();
	mark1 = _tmp10_ / 1000;
	emscripten_set_main_loop_arg (_main_loop_em_arg_callback_func, &ctx, 0, 1);
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	_vala_main (argv, argc);
	return 0;
}


void main_loop (void* arg) {
	Context* ctx = NULL;
	void* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	Context* _tmp2_ = NULL;
	gdouble _tmp3_ = 0.0;
	Context* _tmp4_ = NULL;
	gdouble _tmp5_ = 0.0;
	Context* _tmp6_ = NULL;
	gdouble _tmp7_ = 0.0;
	Context* _tmp8_ = NULL;
	gdouble _tmp9_ = 0.0;
	SDL_Event event = {0};
	_tmp0_ = arg;
	ctx = (Context*) _tmp0_;
	_tmp1_ = emscripten_get_now ();
	(*ctx).mark2 = _tmp1_ / 1000;
	_tmp2_ = ctx;
	_tmp3_ = (*_tmp2_).mark2;
	_tmp4_ = ctx;
	_tmp5_ = (*_tmp4_).mark1;
	(*ctx).delta = _tmp3_ - _tmp5_;
	_tmp6_ = ctx;
	_tmp7_ = (*_tmp6_).mark2;
	(*ctx).mark1 = _tmp7_;
	_tmp8_ = ctx;
	_tmp9_ = (*_tmp8_).delta;
	g_print ("%f\n", _tmp9_);
	while (TRUE) {
		SDL_Event _tmp10_ = {0};
		gint _tmp11_ = 0;
		SDL_Event _tmp12_ = {0};
		guchar _tmp13_ = '\0';
		SDL_Surface* _tmp14_ = NULL;
		SDL_Surface* _tmp15_ = NULL;
		SDL_PixelFormat* _tmp16_ = NULL;
		guint32 _tmp17_ = 0U;
		SDL_Surface* _tmp18_ = NULL;
		SDL_Surface* _tmp19_ = NULL;
		SDL_Surface* _tmp20_ = NULL;
		_tmp11_ = SDL_PollEvent (&_tmp10_);
		event = _tmp10_;
		if (!(_tmp11_ > 0)) {
			break;
		}
		_tmp12_ = event;
		_tmp13_ = _tmp12_.type;
		switch (_tmp13_) {
			case SDL_QUIT:
			{
				{
				}
				break;
			}
			default:
			break;
		}
		_tmp14_ = surface;
		_tmp15_ = surface;
		_tmp16_ = _tmp15_->format;
		_tmp17_ = SDL_MapRGB (_tmp16_, (guchar) 255, (guchar) 0, (guchar) 0);
		SDL_FillRect (_tmp14_, NULL, _tmp17_);
		_tmp18_ = bgd;
		_tmp19_ = surface;
		SDL_UpperBlit (_tmp18_, NULL, _tmp19_, NULL);
		_tmp20_ = surface;
		SDL_Flip (_tmp20_);
	}
}



