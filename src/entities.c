/* entities.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from entities.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_surface.h>
#include <gio/gio.h>
#include <SDL2/SDL_rwops.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_mixer.h>
#include <SDL2/SDL_rect.h>
#include <SDL2/SDL_render.h>
#include <SDL2/SDL_video.h>
#include <gee.h>
#include <gobject/gvaluecollector.h>


#define TYPE_FACTORY (factory_get_type ())
#define FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FACTORY, Factory))
#define FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FACTORY, FactoryClass))
#define IS_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FACTORY))
#define IS_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FACTORY))
#define FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FACTORY, FactoryClass))

typedef struct _Factory Factory;
typedef struct _FactoryClass FactoryClass;
typedef struct _FactoryPrivate FactoryPrivate;
typedef struct _ParamSpecFactory ParamSpecFactory;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_bytes_unref0(var) ((var == NULL) ? NULL : (var = (g_bytes_unref (var), NULL)))
#define _SDL_FreeRW0(var) ((var == NULL) ? NULL : (var = (SDL_FreeRW (var), NULL)))

#define TYPE_GAME (game_get_type ())
#define GAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME, Game))
#define GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME, GameClass))
#define IS_GAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME))
#define IS_GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME))
#define GAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME, GameClass))

typedef struct _Game Game;
typedef struct _GameClass GameClass;

#define TYPE_ENTITY (entity_get_type ())

#define TYPE_ID (id_get_type ())
typedef struct _Id Id;

#define TYPE_NAME (name_get_type ())
typedef struct _Name Name;

#define TYPE_ACTIVE (active_get_type ())
typedef struct _Active Active;

#define TYPE_ACTOR_TYPE (actor_type_get_type ())

#define TYPE_ACTOR (actor_get_type ())
typedef struct _ActorType ActorType;

#define TYPE_ACTOR_STYLE (actor_style_get_type ())

#define TYPE_CATEGORY (category_get_type ())
typedef struct _ActorStyle ActorStyle;

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;

#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;

#define TYPE_SPRITE (sprite_get_type ())
typedef struct _Sprite Sprite;

#define TYPE_SOUND (sound_get_type ())
typedef struct _Sound Sound;

#define TYPE_COLOR (color_get_type ())
typedef struct _Color Color;

#define TYPE_DURATION (duration_get_type ())
typedef struct _Duration Duration;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;

#define TYPE_TWEEN (tween_get_type ())
typedef struct _Tween Tween;
typedef struct _Entity Entity;
typedef struct _GamePrivate GamePrivate;

#define TYPE_METRICS (metrics_get_type ())
typedef struct _Metrics Metrics;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))
#define _sound_free0(var) ((var == NULL) ? NULL : (var = (sound_free (var), NULL)))
#define _color_free0(var) ((var == NULL) ? NULL : (var = (color_free (var), NULL)))
#define _duration_free0(var) ((var == NULL) ? NULL : (var = (duration_free (var), NULL)))
#define _health_free0(var) ((var == NULL) ? NULL : (var = (health_free (var), NULL)))
#define _vector2d_free0(var) ((var == NULL) ? NULL : (var = (vector2d_free (var), NULL)))
#define _tween_free0(var) ((var == NULL) ? NULL : (var = (tween_free (var), NULL)))

struct _Factory {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FactoryPrivate * priv;
};

struct _FactoryClass {
	GTypeClass parent_class;
	void (*finalize) (Factory *self);
};

struct _ParamSpecFactory {
	GParamSpec parent_instance;
};

struct _Id {
	gint id;
};

struct _Name {
	gchar* name;
};

struct _Active {
	gboolean active;
};

typedef enum  {
	ACTOR_BACKGROUND,
	ACTOR_ENEMY1,
	ACTOR_ENEMY2,
	ACTOR_ENEMY3,
	ACTOR_PLAYER,
	ACTOR_BULLET,
	ACTOR_EXPLOSION,
	ACTOR_BANG,
	ACTOR_PARTICLE
} Actor;

struct _ActorType {
	Actor isA;
};

typedef enum  {
	CATEGORY_BACKGROUND,
	CATEGORY_BULLET,
	CATEGORY_ENEMY,
	CATEGORY_EXPLOSION,
	CATEGORY_PARTICLE,
	CATEGORY_PLAYER
} Category;

struct _ActorStyle {
	Category isA;
};

struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Vector2d {
	gdouble x;
	gdouble y;
};

struct _Sprite {
	SDL_Texture* texture;
	gint width;
	gint height;
};

struct _Sound {
	Mix_Chunk* effect;
};

struct _Color {
	gint r;
	gint g;
	gint b;
	gint a;
};

struct _Duration {
	gdouble timer;
};

struct _Health {
	gint current;
	gint maximum;
};

struct _Tween {
	gdouble min;
	gdouble max;
	gdouble speed;
	gboolean repeat;
	gboolean active;
};

struct _Entity {
	Id id;
	Name name;
	Active active;
	ActorType actor;
	ActorStyle style;
	Point2d position;
	SDL_Rect bounds;
	Vector2d scale;
	Sprite sprite;
	Sound* sound;
	Color* tint;
	Duration* expires;
	Health* health;
	Tween* tween;
	Vector2d* velocity;
};

struct _Metrics {
	gint bullet;
	gint enemy1;
	gint enemy2;
	gint enemy3;
	gint explosion;
	gint bang;
	gint particle;
	gint count;
};

struct _Game {
	GObject parent_instance;
	GamePrivate * priv;
	gchar* title;
	gint width;
	gint height;
	gint fps;
	gint mouseX;
	gint mouseY;
	gboolean mouseDown;
	gdouble delta;
	gdouble FireRate;
	gdouble timeToFire;
	gdouble enemyT1;
	gdouble enemyT2;
	gdouble enemyT3;
	GRand* rand;
	Entity* player;
	SDL_Window* window;
	SDL_Renderer* renderer;
	Entity* pool;
	gint pool_length1;
	guint8* keys;
	gint keys_length1;
	GeeArrayList* sprites;
	GeeArrayList* entity;
	GeeArrayList* unused;
	GeeArrayList* bullets;
	GeeArrayList* enemies1;
	GeeArrayList* enemies2;
	GeeArrayList* enemies3;
	GeeArrayList* explosions;
	GeeArrayList* bangs;
	GeeArrayList* particles;
	Metrics missing;
};

struct _GameClass {
	GObjectClass parent_class;
};


static gpointer factory_parent_class = NULL;
extern gint factory_id;
gint factory_id = 0;

#define Tau (2.0 * G_PI)
gpointer factory_ref (gpointer instance);
void factory_unref (gpointer instance);
GParamSpec* param_spec_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_factory (GValue* value, gpointer v_object);
void value_take_factory (GValue* value, gpointer v_object);
gpointer value_get_factory (const GValue* value);
GType factory_get_type (void) G_GNUC_CONST;
enum  {
	FACTORY_DUMMY_PROPERTY
};
Factory* factory_new (void);
Factory* factory_construct (GType object_type);
static void factory_finalize (Factory * obj);
SDL_Surface* getImage (const gchar* name);
Mix_Chunk* getSound (const gchar* name);
GType game_get_type (void) G_GNUC_CONST;
GType entity_get_type (void) G_GNUC_CONST;
GType id_get_type (void) G_GNUC_CONST;
Id* id_dup (const Id* self);
void id_free (Id* self);
GType name_get_type (void) G_GNUC_CONST;
Name* name_dup (const Name* self);
void name_free (Name* self);
void name_copy (const Name* self, Name* dest);
void name_destroy (Name* self);
GType active_get_type (void) G_GNUC_CONST;
Active* active_dup (const Active* self);
void active_free (Active* self);
GType actor_type_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
ActorType* actor_type_dup (const ActorType* self);
void actor_type_free (ActorType* self);
GType actor_style_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
ActorStyle* actor_style_dup (const ActorStyle* self);
void actor_style_free (ActorStyle* self);
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
GType sprite_get_type (void) G_GNUC_CONST;
Sprite* sprite_dup (const Sprite* self);
void sprite_free (Sprite* self);
GType sound_get_type (void) G_GNUC_CONST;
Sound* sound_dup (const Sound* self);
void sound_free (Sound* self);
GType color_get_type (void) G_GNUC_CONST;
Color* color_dup (const Color* self);
void color_free (Color* self);
GType duration_get_type (void) G_GNUC_CONST;
Duration* duration_dup (const Duration* self);
void duration_free (Duration* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
GType tween_get_type (void) G_GNUC_CONST;
Tween* tween_dup (const Tween* self);
void tween_free (Tween* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
Entity* createBackground (Game* game, Entity* pool, int pool_length1);
GType metrics_get_type (void) G_GNUC_CONST;
Metrics* metrics_dup (const Metrics* self);
void metrics_free (Metrics* self);
Entity* createPlayer (Game* game, Entity* pool, int pool_length1);
Entity* createBullet (Game* game, Entity* pool, int pool_length1);
void initBullet (Game* game, Entity** entity, gint x, gint y);
void game_addSprite (Game* self, Entity* e);
Entity* createEnemy1 (Game* game, Entity* pool, int pool_length1);
void initEnemy1 (Game* game, Entity** entity, gint x, gint y);
Entity* createEnemy2 (Game* game, Entity* pool, int pool_length1);
void initEnemy2 (Game* game, Entity** entity, gint x, gint y);
Entity* createEnemy3 (Game* game, Entity* pool, int pool_length1);
void initEnemy3 (Game* game, Entity** entity, gint x, gint y);
Entity* createExplosion (Game* game, Entity* pool, int pool_length1);
void initExplosion (Game* game, Entity** entity, gint x, gint y);
Entity* createBang (Game* game, Entity* pool, int pool_length1);
void initBang (Game* game, Entity** entity, gint x, gint y);
Entity* createParticle (Game* game, Entity* pool, int pool_length1);
void initParticle (Game* game, Entity** entity, gint x, gint y);


Factory* factory_construct (GType object_type) {
	Factory* self = NULL;
	self = (Factory*) g_type_create_instance (object_type);
	return self;
}


Factory* factory_new (void) {
	return factory_construct (TYPE_FACTORY);
}


static void value_factory_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_factory_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		factory_unref (value->data[0].v_pointer);
	}
}


static void value_factory_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = factory_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_factory_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_factory_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Factory * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = factory_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_factory_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Factory ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = factory_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecFactory* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FACTORY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_factory (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FACTORY), NULL);
	return value->data[0].v_pointer;
}


void value_set_factory (GValue* value, gpointer v_object) {
	Factory * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FACTORY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FACTORY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		factory_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		factory_unref (old);
	}
}


void value_take_factory (GValue* value, gpointer v_object) {
	Factory * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FACTORY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FACTORY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		factory_unref (old);
	}
}


static void factory_class_init (FactoryClass * klass) {
	factory_parent_class = g_type_class_peek_parent (klass);
	((FactoryClass *) klass)->finalize = factory_finalize;
}


static void factory_instance_init (Factory * self) {
	self->ref_count = 1;
}


static void factory_finalize (Factory * obj) {
	Factory * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FACTORY, Factory);
	g_signal_handlers_destroy (self);
}


GType factory_get_type (void) {
	static volatile gsize factory_type_id__volatile = 0;
	if (g_once_init_enter (&factory_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_factory_init, value_factory_free_value, value_factory_copy_value, value_factory_peek_pointer, "p", value_factory_collect_value, "p", value_factory_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (FactoryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) factory_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Factory), 0, (GInstanceInitFunc) factory_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType factory_type_id;
		factory_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Factory", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&factory_type_id__volatile, factory_type_id);
	}
	return factory_type_id__volatile;
}


gpointer factory_ref (gpointer instance) {
	Factory * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void factory_unref (gpointer instance) {
	Factory * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FACTORY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


/**
 * getImage
 *
 * gets resource from gio resource compiler 
 *
 * @param name
 * @return surface
 */
SDL_Surface* getImage (const gchar* name) {
	SDL_Surface* result = NULL;
	GBytes* ptr = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	GBytes* _tmp3_;
	GBytes* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = name;
	_tmp1_ = g_strconcat ("/darkoverlordofdata/shmupwarz/assets/images/", _tmp0_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_resources_lookup_data (_tmp2_, 0, &_inner_error_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	ptr = _tmp4_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	if (ptr == NULL) {
		result = NULL;
		_g_bytes_unref0 (ptr);
		return result;
	} else {
		SDL_RWops* raw = NULL;
		gsize _tmp5_;
		guint8* _tmp6_;
		gsize _tmp7_;
		SDL_RWops* _tmp8_;
		SDL_RWops* _tmp9_;
		SDL_Surface* _tmp10_;
		_tmp6_ = g_bytes_get_data (ptr, &_tmp5_);
		_tmp7_ = g_bytes_get_size (ptr);
		_tmp8_ = SDL_RWFromMem ((void*) _tmp6_, (gint) _tmp7_);
		raw = _tmp8_;
		_tmp9_ = raw;
		_tmp10_ = IMG_LoadPNG_RW (_tmp9_);
		result = _tmp10_;
		_SDL_FreeRW0 (raw);
		_g_bytes_unref0 (ptr);
		return result;
	}
	_g_bytes_unref0 (ptr);
}


Mix_Chunk* getSound (const gchar* name) {
	Mix_Chunk* result = NULL;
	GBytes* ptr = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	GBytes* _tmp3_;
	GBytes* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = name;
	_tmp1_ = g_strconcat ("/darkoverlordofdata/shmupwarz/assets/sounds/", _tmp0_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_resources_lookup_data (_tmp2_, 0, &_inner_error_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	ptr = _tmp4_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	if (ptr == NULL) {
		result = NULL;
		_g_bytes_unref0 (ptr);
		return result;
	} else {
		SDL_RWops* raw = NULL;
		gsize _tmp5_;
		guint8* _tmp6_;
		gsize _tmp7_;
		SDL_RWops* _tmp8_;
		SDL_RWops* _tmp9_;
		Mix_Chunk* _tmp10_;
		_tmp6_ = g_bytes_get_data (ptr, &_tmp5_);
		_tmp7_ = g_bytes_get_size (ptr);
		_tmp8_ = SDL_RWFromMem ((void*) _tmp6_, (gint) _tmp7_);
		raw = _tmp8_;
		_tmp9_ = raw;
		_tmp10_ = Mix_LoadWAV_RW (_tmp9_, 0);
		result = _tmp10_;
		_SDL_FreeRW0 (raw);
		_g_bytes_unref0 (ptr);
		return result;
	}
	_g_bytes_unref0 (ptr);
}


/**
 * createBackground
 *
 * create background entity 
 *
 * @param game
 * @return id
 */
Entity* createBackground (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Entity _tmp18_ = {0};
	Entity _tmp19_;
	Entity* _tmp20_;
	gint _tmp20__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 2.0;
	_tmp0_ = getImage ("background.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("background");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = TRUE;
	_tmp9_.isA = ACTOR_BACKGROUND;
	_tmp10_.isA = CATEGORY_BACKGROUND;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	memset (&_tmp18_, 0, sizeof (Entity));
	_tmp18_.id = _tmp5_;
	name_destroy (&_tmp18_.name);
	_tmp18_.name = _tmp7_;
	_tmp18_.active = _tmp8_;
	_tmp18_.actor = _tmp9_;
	_tmp18_.style = _tmp10_;
	_tmp18_.position = _tmp11_;
	_tmp18_.bounds = _tmp12_;
	_tmp18_.scale = _tmp13_;
	_tmp18_.sprite = _tmp17_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp18_;
	_tmp19_ = _tmp4_[id];
	_tmp20_ = pool;
	_tmp20__length1 = pool_length1;
	result = &_tmp20_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


Entity* createPlayer (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Entity _tmp18_ = {0};
	Entity _tmp19_;
	Entity* _tmp20_;
	gint _tmp20__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 1.0;
	_tmp0_ = getImage ("spaceshipspr.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("player");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = TRUE;
	_tmp9_.isA = ACTOR_PLAYER;
	_tmp10_.isA = CATEGORY_PLAYER;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	memset (&_tmp18_, 0, sizeof (Entity));
	_tmp18_.id = _tmp5_;
	name_destroy (&_tmp18_.name);
	_tmp18_.name = _tmp7_;
	_tmp18_.active = _tmp8_;
	_tmp18_.actor = _tmp9_;
	_tmp18_.style = _tmp10_;
	_tmp18_.position = _tmp11_;
	_tmp18_.bounds = _tmp12_;
	_tmp18_.scale = _tmp13_;
	_tmp18_.sprite = _tmp17_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp18_;
	_tmp19_ = _tmp4_[id];
	_tmp20_ = pool;
	_tmp20__length1 = pool_length1;
	result = &_tmp20_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


static gpointer _sound_dup0 (gpointer self) {
	return self ? sound_dup (self) : NULL;
}


static gpointer _color_dup0 (gpointer self) {
	return self ? color_dup (self) : NULL;
}


static gpointer _duration_dup0 (gpointer self) {
	return self ? duration_dup (self) : NULL;
}


static gpointer _health_dup0 (gpointer self) {
	return self ? health_dup (self) : NULL;
}


static gpointer _vector2d_dup0 (gpointer self) {
	return self ? vector2d_dup (self) : NULL;
}


Entity* createBullet (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Mix_Chunk* _tmp18_;
	Sound _tmp19_ = {0};
	Sound* _tmp20_;
	Color _tmp21_ = {0};
	Color* _tmp22_;
	Duration _tmp23_ = {0};
	Duration* _tmp24_;
	Health _tmp25_ = {0};
	Health* _tmp26_;
	Vector2d _tmp27_ = {0};
	Vector2d* _tmp28_;
	Entity _tmp29_ = {0};
	Entity _tmp30_;
	Entity* _tmp31_;
	gint _tmp31__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 1.0;
	_tmp0_ = getImage ("bullet.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("bullet");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = FALSE;
	_tmp9_.isA = ACTOR_BULLET;
	_tmp10_.isA = CATEGORY_BULLET;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	_tmp18_ = getSound ("pew.wav");
	_tmp19_.effect = _tmp18_;
	_tmp20_ = _sound_dup0 (&_tmp19_);
	_tmp21_.r = 0xd2;
	_tmp21_.g = 0xfa;
	_tmp21_.b = 0x00;
	_tmp21_.a = 0xffa;
	_tmp22_ = _color_dup0 (&_tmp21_);
	_tmp23_.timer = 1.0;
	_tmp24_ = _duration_dup0 (&_tmp23_);
	_tmp25_.current = 2;
	_tmp25_.maximum = 2;
	_tmp26_ = _health_dup0 (&_tmp25_);
	_tmp27_.x = (gdouble) 0;
	_tmp27_.y = (gdouble) -800;
	_tmp28_ = _vector2d_dup0 (&_tmp27_);
	memset (&_tmp29_, 0, sizeof (Entity));
	_tmp29_.id = _tmp5_;
	name_destroy (&_tmp29_.name);
	_tmp29_.name = _tmp7_;
	_tmp29_.active = _tmp8_;
	_tmp29_.actor = _tmp9_;
	_tmp29_.style = _tmp10_;
	_tmp29_.position = _tmp11_;
	_tmp29_.bounds = _tmp12_;
	_tmp29_.scale = _tmp13_;
	_tmp29_.sprite = _tmp17_;
	_sound_free0 (_tmp29_.sound);
	_tmp29_.sound = _tmp20_;
	_color_free0 (_tmp29_.tint);
	_tmp29_.tint = _tmp22_;
	_duration_free0 (_tmp29_.expires);
	_tmp29_.expires = _tmp24_;
	_health_free0 (_tmp29_.health);
	_tmp29_.health = _tmp26_;
	_vector2d_free0 (_tmp29_.velocity);
	_tmp29_.velocity = _tmp28_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp29_;
	_tmp30_ = _tmp4_[id];
	_tmp31_ = pool;
	_tmp31__length1 = pool_length1;
	result = &_tmp31_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


void initBullet (Game* game, Entity** entity, gint x, gint y) {
	gint _tmp0_;
	gint _tmp1_;
	Entity* _tmp2_;
	Duration* _tmp3_;
	Game* _tmp4_;
	Entity* _tmp5_;
	g_return_if_fail (game != NULL);
	_tmp0_ = x;
	(*(*entity)).position.x = (gdouble) _tmp0_;
	_tmp1_ = y;
	(*(*entity)).position.y = (gdouble) _tmp1_;
	_tmp2_ = *entity;
	_tmp3_ = (*_tmp2_).expires;
	(*_tmp3_).timer = 1.0;
	(*(*entity)).active.active = TRUE;
	_tmp4_ = game;
	_tmp5_ = *entity;
	game_addSprite (_tmp4_, _tmp5_);
}


Entity* createEnemy1 (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Health _tmp18_ = {0};
	Health* _tmp19_;
	Vector2d _tmp20_ = {0};
	Vector2d* _tmp21_;
	Entity _tmp22_ = {0};
	Entity _tmp23_;
	Entity* _tmp24_;
	gint _tmp24__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 1.0;
	_tmp0_ = getImage ("enemy1.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("enemy1");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = FALSE;
	_tmp9_.isA = ACTOR_ENEMY1;
	_tmp10_.isA = CATEGORY_ENEMY;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	_tmp18_.current = 10;
	_tmp18_.maximum = 10;
	_tmp19_ = _health_dup0 (&_tmp18_);
	_tmp20_.x = (gdouble) 0;
	_tmp20_.y = (gdouble) 40;
	_tmp21_ = _vector2d_dup0 (&_tmp20_);
	memset (&_tmp22_, 0, sizeof (Entity));
	_tmp22_.id = _tmp5_;
	name_destroy (&_tmp22_.name);
	_tmp22_.name = _tmp7_;
	_tmp22_.active = _tmp8_;
	_tmp22_.actor = _tmp9_;
	_tmp22_.style = _tmp10_;
	_tmp22_.position = _tmp11_;
	_tmp22_.bounds = _tmp12_;
	_tmp22_.scale = _tmp13_;
	_tmp22_.sprite = _tmp17_;
	_health_free0 (_tmp22_.health);
	_tmp22_.health = _tmp19_;
	_vector2d_free0 (_tmp22_.velocity);
	_tmp22_.velocity = _tmp21_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp22_;
	_tmp23_ = _tmp4_[id];
	_tmp24_ = pool;
	_tmp24__length1 = pool_length1;
	result = &_tmp24_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


void initEnemy1 (Game* game, Entity** entity, gint x, gint y) {
	gint _tmp0_;
	gint _tmp1_;
	Entity* _tmp2_;
	Health* _tmp3_;
	Game* _tmp4_;
	Entity* _tmp5_;
	g_return_if_fail (game != NULL);
	_tmp0_ = x;
	(*(*entity)).position.x = (gdouble) _tmp0_;
	_tmp1_ = y;
	(*(*entity)).position.y = (gdouble) _tmp1_;
	_tmp2_ = *entity;
	_tmp3_ = (*_tmp2_).health;
	(*_tmp3_).current = 10;
	(*(*entity)).active.active = TRUE;
	_tmp4_ = game;
	_tmp5_ = *entity;
	game_addSprite (_tmp4_, _tmp5_);
}


Entity* createEnemy2 (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Health _tmp18_ = {0};
	Health* _tmp19_;
	Vector2d _tmp20_ = {0};
	Vector2d* _tmp21_;
	Entity _tmp22_ = {0};
	Entity _tmp23_;
	Entity* _tmp24_;
	gint _tmp24__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 1.0;
	_tmp0_ = getImage ("enemy2.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("enemy2");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = FALSE;
	_tmp9_.isA = ACTOR_ENEMY2;
	_tmp10_.isA = CATEGORY_ENEMY;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	_tmp18_.current = 20;
	_tmp18_.maximum = 20;
	_tmp19_ = _health_dup0 (&_tmp18_);
	_tmp20_.x = (gdouble) 0;
	_tmp20_.y = (gdouble) 30;
	_tmp21_ = _vector2d_dup0 (&_tmp20_);
	memset (&_tmp22_, 0, sizeof (Entity));
	_tmp22_.id = _tmp5_;
	name_destroy (&_tmp22_.name);
	_tmp22_.name = _tmp7_;
	_tmp22_.active = _tmp8_;
	_tmp22_.actor = _tmp9_;
	_tmp22_.style = _tmp10_;
	_tmp22_.position = _tmp11_;
	_tmp22_.bounds = _tmp12_;
	_tmp22_.scale = _tmp13_;
	_tmp22_.sprite = _tmp17_;
	_health_free0 (_tmp22_.health);
	_tmp22_.health = _tmp19_;
	_vector2d_free0 (_tmp22_.velocity);
	_tmp22_.velocity = _tmp21_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp22_;
	_tmp23_ = _tmp4_[id];
	_tmp24_ = pool;
	_tmp24__length1 = pool_length1;
	result = &_tmp24_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


void initEnemy2 (Game* game, Entity** entity, gint x, gint y) {
	gint _tmp0_;
	gint _tmp1_;
	Entity* _tmp2_;
	Health* _tmp3_;
	Game* _tmp4_;
	Entity* _tmp5_;
	g_return_if_fail (game != NULL);
	_tmp0_ = x;
	(*(*entity)).position.x = (gdouble) _tmp0_;
	_tmp1_ = y;
	(*(*entity)).position.y = (gdouble) _tmp1_;
	_tmp2_ = *entity;
	_tmp3_ = (*_tmp2_).health;
	(*_tmp3_).current = 20;
	(*(*entity)).active.active = TRUE;
	_tmp4_ = game;
	_tmp5_ = *entity;
	game_addSprite (_tmp4_, _tmp5_);
}


Entity* createEnemy3 (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Health _tmp18_ = {0};
	Health* _tmp19_;
	Vector2d _tmp20_ = {0};
	Vector2d* _tmp21_;
	Entity _tmp22_ = {0};
	Entity _tmp23_;
	Entity* _tmp24_;
	gint _tmp24__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 1.0;
	_tmp0_ = getImage ("enemy3.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("enemy3");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = FALSE;
	_tmp9_.isA = ACTOR_ENEMY3;
	_tmp10_.isA = CATEGORY_ENEMY;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	_tmp18_.current = 60;
	_tmp18_.maximum = 60;
	_tmp19_ = _health_dup0 (&_tmp18_);
	_tmp20_.x = (gdouble) 0;
	_tmp20_.y = (gdouble) 20;
	_tmp21_ = _vector2d_dup0 (&_tmp20_);
	memset (&_tmp22_, 0, sizeof (Entity));
	_tmp22_.id = _tmp5_;
	name_destroy (&_tmp22_.name);
	_tmp22_.name = _tmp7_;
	_tmp22_.active = _tmp8_;
	_tmp22_.actor = _tmp9_;
	_tmp22_.style = _tmp10_;
	_tmp22_.position = _tmp11_;
	_tmp22_.bounds = _tmp12_;
	_tmp22_.scale = _tmp13_;
	_tmp22_.sprite = _tmp17_;
	_health_free0 (_tmp22_.health);
	_tmp22_.health = _tmp19_;
	_vector2d_free0 (_tmp22_.velocity);
	_tmp22_.velocity = _tmp21_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp22_;
	_tmp23_ = _tmp4_[id];
	_tmp24_ = pool;
	_tmp24__length1 = pool_length1;
	result = &_tmp24_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


void initEnemy3 (Game* game, Entity** entity, gint x, gint y) {
	gint _tmp0_;
	gint _tmp1_;
	Entity* _tmp2_;
	Health* _tmp3_;
	Game* _tmp4_;
	Entity* _tmp5_;
	g_return_if_fail (game != NULL);
	_tmp0_ = x;
	(*(*entity)).position.x = (gdouble) _tmp0_;
	_tmp1_ = y;
	(*(*entity)).position.y = (gdouble) _tmp1_;
	_tmp2_ = *entity;
	_tmp3_ = (*_tmp2_).health;
	(*_tmp3_).current = 60;
	(*(*entity)).active.active = TRUE;
	_tmp4_ = game;
	_tmp5_ = *entity;
	game_addSprite (_tmp4_, _tmp5_);
}


static gpointer _tween_dup0 (gpointer self) {
	return self ? tween_dup (self) : NULL;
}


Entity* createExplosion (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Mix_Chunk* _tmp18_;
	Sound _tmp19_ = {0};
	Sound* _tmp20_;
	Color _tmp21_ = {0};
	Color* _tmp22_;
	Duration _tmp23_ = {0};
	Duration* _tmp24_;
	Tween _tmp25_ = {0};
	Tween* _tmp26_;
	Entity _tmp27_ = {0};
	Entity _tmp28_;
	Entity* _tmp29_;
	gint _tmp29__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 0.6;
	_tmp0_ = getImage ("explosion.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("explosion");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = FALSE;
	_tmp9_.isA = ACTOR_EXPLOSION;
	_tmp10_.isA = CATEGORY_EXPLOSION;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	_tmp18_ = getSound ("asplode.wav");
	_tmp19_.effect = _tmp18_;
	_tmp20_ = _sound_dup0 (&_tmp19_);
	_tmp21_.r = 0xd2;
	_tmp21_.g = 0xfa;
	_tmp21_.b = 0xd2;
	_tmp21_.a = 0xfa;
	_tmp22_ = _color_dup0 (&_tmp21_);
	_tmp23_.timer = 0.2;
	_tmp24_ = _duration_dup0 (&_tmp23_);
	_tmp25_.min = scale / 100.0;
	_tmp25_.max = scale;
	_tmp25_.speed = (gdouble) -3;
	_tmp25_.repeat = FALSE;
	_tmp25_.active = TRUE;
	_tmp26_ = _tween_dup0 (&_tmp25_);
	memset (&_tmp27_, 0, sizeof (Entity));
	_tmp27_.id = _tmp5_;
	name_destroy (&_tmp27_.name);
	_tmp27_.name = _tmp7_;
	_tmp27_.active = _tmp8_;
	_tmp27_.actor = _tmp9_;
	_tmp27_.style = _tmp10_;
	_tmp27_.position = _tmp11_;
	_tmp27_.bounds = _tmp12_;
	_tmp27_.scale = _tmp13_;
	_tmp27_.sprite = _tmp17_;
	_sound_free0 (_tmp27_.sound);
	_tmp27_.sound = _tmp20_;
	_color_free0 (_tmp27_.tint);
	_tmp27_.tint = _tmp22_;
	_duration_free0 (_tmp27_.expires);
	_tmp27_.expires = _tmp24_;
	_tween_free0 (_tmp27_.tween);
	_tmp27_.tween = _tmp26_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp27_;
	_tmp28_ = _tmp4_[id];
	_tmp29_ = pool;
	_tmp29__length1 = pool_length1;
	result = &_tmp29_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


void initExplosion (Game* game, Entity** entity, gint x, gint y) {
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	Entity* _tmp4_;
	Tween* _tmp5_;
	Entity* _tmp6_;
	Duration* _tmp7_;
	Game* _tmp8_;
	Entity* _tmp9_;
	g_return_if_fail (game != NULL);
	_tmp0_ = x;
	(*(*entity)).position.x = (gdouble) _tmp0_;
	_tmp1_ = y;
	(*(*entity)).position.y = (gdouble) _tmp1_;
	_tmp2_ = x;
	(*(*entity)).bounds.x = _tmp2_;
	_tmp3_ = y;
	(*(*entity)).bounds.y = _tmp3_;
	(*(*entity)).scale.x = 0.6;
	(*(*entity)).scale.y = 0.6;
	_tmp4_ = *entity;
	_tmp5_ = (*_tmp4_).tween;
	(*_tmp5_).active = TRUE;
	_tmp6_ = *entity;
	_tmp7_ = (*_tmp6_).expires;
	(*_tmp7_).timer = 0.2;
	(*(*entity)).active.active = TRUE;
	_tmp8_ = game;
	_tmp9_ = *entity;
	game_addSprite (_tmp8_, _tmp9_);
}


Entity* createBang (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Mix_Chunk* _tmp18_;
	Sound _tmp19_ = {0};
	Sound* _tmp20_;
	Color _tmp21_ = {0};
	Color* _tmp22_;
	Duration _tmp23_ = {0};
	Duration* _tmp24_;
	Tween _tmp25_ = {0};
	Tween* _tmp26_;
	Entity _tmp27_ = {0};
	Entity _tmp28_;
	Entity* _tmp29_;
	gint _tmp29__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 0.4;
	_tmp0_ = getImage ("explosion.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("bang");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = FALSE;
	_tmp9_.isA = ACTOR_BANG;
	_tmp10_.isA = CATEGORY_EXPLOSION;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	_tmp18_ = getSound ("smallasplode.wav");
	_tmp19_.effect = _tmp18_;
	_tmp20_ = _sound_dup0 (&_tmp19_);
	_tmp21_.r = 0xd2;
	_tmp21_.g = 0xfa;
	_tmp21_.b = 0xd2;
	_tmp21_.a = 0xfa;
	_tmp22_ = _color_dup0 (&_tmp21_);
	_tmp23_.timer = 0.2;
	_tmp24_ = _duration_dup0 (&_tmp23_);
	_tmp25_.min = scale / 100.0;
	_tmp25_.max = scale;
	_tmp25_.speed = (gdouble) -3;
	_tmp25_.repeat = FALSE;
	_tmp25_.active = TRUE;
	_tmp26_ = _tween_dup0 (&_tmp25_);
	memset (&_tmp27_, 0, sizeof (Entity));
	_tmp27_.id = _tmp5_;
	name_destroy (&_tmp27_.name);
	_tmp27_.name = _tmp7_;
	_tmp27_.active = _tmp8_;
	_tmp27_.actor = _tmp9_;
	_tmp27_.style = _tmp10_;
	_tmp27_.position = _tmp11_;
	_tmp27_.bounds = _tmp12_;
	_tmp27_.scale = _tmp13_;
	_tmp27_.sprite = _tmp17_;
	_sound_free0 (_tmp27_.sound);
	_tmp27_.sound = _tmp20_;
	_color_free0 (_tmp27_.tint);
	_tmp27_.tint = _tmp22_;
	_duration_free0 (_tmp27_.expires);
	_tmp27_.expires = _tmp24_;
	_tween_free0 (_tmp27_.tween);
	_tmp27_.tween = _tmp26_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp27_;
	_tmp28_ = _tmp4_[id];
	_tmp29_ = pool;
	_tmp29__length1 = pool_length1;
	result = &_tmp29_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


void initBang (Game* game, Entity** entity, gint x, gint y) {
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	Entity* _tmp4_;
	Tween* _tmp5_;
	Entity* _tmp6_;
	Duration* _tmp7_;
	Game* _tmp8_;
	Entity* _tmp9_;
	g_return_if_fail (game != NULL);
	_tmp0_ = x;
	(*(*entity)).position.x = (gdouble) _tmp0_;
	_tmp1_ = y;
	(*(*entity)).position.y = (gdouble) _tmp1_;
	_tmp2_ = x;
	(*(*entity)).bounds.x = _tmp2_;
	_tmp3_ = y;
	(*(*entity)).bounds.y = _tmp3_;
	(*(*entity)).scale.x = 0.4;
	(*(*entity)).scale.y = 0.4;
	_tmp4_ = *entity;
	_tmp5_ = (*_tmp4_).tween;
	(*_tmp5_).active = TRUE;
	_tmp6_ = *entity;
	_tmp7_ = (*_tmp6_).expires;
	(*_tmp7_).timer = 0.2;
	(*(*entity)).active.active = TRUE;
	_tmp8_ = game;
	_tmp9_ = *entity;
	game_addSprite (_tmp8_, _tmp9_);
}


Entity* createParticle (Game* game, Entity* pool, int pool_length1) {
	Entity* result = NULL;
	gdouble scale = 0.0;
	SDL_Surface* surface = NULL;
	SDL_Surface* _tmp0_;
	gint w = 0;
	gint _tmp1_;
	gint h = 0;
	gint _tmp2_;
	gint id = 0;
	gint _tmp3_;
	Entity* _tmp4_;
	gint _tmp4__length1;
	Id _tmp5_ = {0};
	gchar* _tmp6_;
	Name _tmp7_ = {0};
	Active _tmp8_ = {0};
	ActorType _tmp9_ = {0};
	ActorStyle _tmp10_ = {0};
	Point2d _tmp11_ = {0};
	SDL_Rect _tmp12_ = {0};
	Vector2d _tmp13_ = {0};
	Game* _tmp14_;
	SDL_Renderer* _tmp15_;
	SDL_Texture* _tmp16_;
	Sprite _tmp17_ = {0};
	Color _tmp18_ = {0};
	Color* _tmp19_;
	Duration _tmp20_ = {0};
	Duration* _tmp21_;
	Vector2d _tmp22_ = {0};
	Vector2d* _tmp23_;
	Entity _tmp24_ = {0};
	Entity _tmp25_;
	Entity* _tmp26_;
	gint _tmp26__length1;
	g_return_val_if_fail (game != NULL, NULL);
	scale = 1.0;
	_tmp0_ = getImage ("star.png");
	surface = _tmp0_;
	_tmp1_ = surface->w;
	w = (gint) (((gdouble) _tmp1_) * scale);
	_tmp2_ = surface->h;
	h = (gint) (((gdouble) _tmp2_) * scale);
	_tmp3_ = factory_id;
	factory_id = _tmp3_ + 1;
	id = _tmp3_;
	_tmp4_ = pool;
	_tmp4__length1 = pool_length1;
	_tmp5_.id = id;
	_tmp6_ = g_strdup ("particle");
	_g_free0 (_tmp7_.name);
	_tmp7_.name = _tmp6_;
	_tmp8_.active = FALSE;
	_tmp9_.isA = ACTOR_PARTICLE;
	_tmp10_.isA = CATEGORY_PARTICLE;
	_tmp11_.x = (gdouble) 0;
	_tmp11_.y = (gdouble) 0;
	_tmp12_.x = 0;
	_tmp12_.y = 0;
	_tmp12_.w = (guint) w;
	_tmp12_.h = (guint) h;
	_tmp13_.x = scale;
	_tmp13_.y = scale;
	_tmp14_ = game;
	_tmp15_ = _tmp14_->renderer;
	_tmp16_ = SDL_CreateTextureFromSurface (_tmp15_, surface);
	_tmp17_.texture = _tmp16_;
	_tmp17_.width = w;
	_tmp17_.height = h;
	_tmp18_.r = 0xd2;
	_tmp18_.g = 0xfa;
	_tmp18_.b = 0xd2;
	_tmp18_.a = 0xfa;
	_tmp19_ = _color_dup0 (&_tmp18_);
	_tmp20_.timer = 0.75;
	_tmp21_ = _duration_dup0 (&_tmp20_);
	_tmp22_.x = (gdouble) 0;
	_tmp22_.y = (gdouble) 0;
	_tmp23_ = _vector2d_dup0 (&_tmp22_);
	memset (&_tmp24_, 0, sizeof (Entity));
	_tmp24_.id = _tmp5_;
	name_destroy (&_tmp24_.name);
	_tmp24_.name = _tmp7_;
	_tmp24_.active = _tmp8_;
	_tmp24_.actor = _tmp9_;
	_tmp24_.style = _tmp10_;
	_tmp24_.position = _tmp11_;
	_tmp24_.bounds = _tmp12_;
	_tmp24_.scale = _tmp13_;
	_tmp24_.sprite = _tmp17_;
	_color_free0 (_tmp24_.tint);
	_tmp24_.tint = _tmp19_;
	_duration_free0 (_tmp24_.expires);
	_tmp24_.expires = _tmp21_;
	_vector2d_free0 (_tmp24_.velocity);
	_tmp24_.velocity = _tmp23_;
	entity_destroy (&_tmp4_[id]);
	_tmp4_[id] = _tmp24_;
	_tmp25_ = _tmp4_[id];
	_tmp26_ = pool;
	_tmp26__length1 = pool_length1;
	result = &_tmp26_[id];
	_SDL_FreeSurface0 (surface);
	return result;
}


void initParticle (Game* game, Entity** entity, gint x, gint y) {
	gdouble radians = 0.0;
	Game* _tmp0_;
	GRand* _tmp1_;
	gdouble _tmp2_;
	gint32 magnitude = 0;
	Game* _tmp3_;
	GRand* _tmp4_;
	gint32 _tmp5_;
	gdouble velocityX = 0.0;
	gdouble _tmp6_;
	gdouble velocityY = 0.0;
	gdouble _tmp7_;
	gdouble scale = 0.0;
	Game* _tmp8_;
	GRand* _tmp9_;
	gdouble _tmp10_;
	gint _tmp11_;
	gint _tmp12_;
	gint _tmp13_;
	gint _tmp14_;
	Entity* _tmp15_;
	Vector2d* _tmp16_;
	Entity* _tmp17_;
	Vector2d* _tmp18_;
	Entity* _tmp19_;
	Duration* _tmp20_;
	Game* _tmp21_;
	Entity* _tmp22_;
	g_return_if_fail (game != NULL);
	_tmp0_ = game;
	_tmp1_ = _tmp0_->rand;
	_tmp2_ = g_rand_double (_tmp1_);
	radians = _tmp2_ * Tau;
	_tmp3_ = game;
	_tmp4_ = _tmp3_->rand;
	_tmp5_ = g_rand_int_range (_tmp4_, (gint32) 0, (gint32) 200);
	magnitude = _tmp5_;
	_tmp6_ = cos (radians);
	velocityX = magnitude * _tmp6_;
	_tmp7_ = sin (radians);
	velocityY = magnitude * _tmp7_;
	_tmp8_ = game;
	_tmp9_ = _tmp8_->rand;
	_tmp10_ = g_rand_double_range (_tmp9_, 0.1, 1.0);
	scale = _tmp10_;
	_tmp11_ = x;
	(*(*entity)).position.x = (gdouble) _tmp11_;
	_tmp12_ = y;
	(*(*entity)).position.y = (gdouble) _tmp12_;
	_tmp13_ = x;
	(*(*entity)).bounds.x = _tmp13_;
	_tmp14_ = y;
	(*(*entity)).bounds.y = _tmp14_;
	(*(*entity)).scale.x = scale;
	(*(*entity)).scale.y = scale;
	_tmp15_ = *entity;
	_tmp16_ = (*_tmp15_).velocity;
	(*_tmp16_).x = velocityX;
	_tmp17_ = *entity;
	_tmp18_ = (*_tmp17_).velocity;
	(*_tmp18_).y = velocityY;
	_tmp19_ = *entity;
	_tmp20_ = (*_tmp19_).expires;
	(*_tmp20_).timer = 0.75;
	(*(*entity)).active.active = TRUE;
	_tmp21_ = game;
	_tmp22_ = *entity;
	game_addSprite (_tmp21_, _tmp22_);
}



