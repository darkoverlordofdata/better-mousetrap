/* game.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from game.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <SDL2/SDL_rect.h>
#include <SDL2/SDL_render.h>
#include <SDL2/SDL_mixer.h>
#include <SDL2/SDL_video.h>
#include <gee.h>
#include <SDL2/SDL_events.h>
#include <SDL2/SDL_keyboard.h>


#define TYPE_GAME (game_get_type ())
#define GAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME, Game))
#define GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME, GameClass))
#define IS_GAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME))
#define IS_GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME))
#define GAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME, GameClass))

typedef struct _Game Game;
typedef struct _GameClass GameClass;
typedef struct _GamePrivate GamePrivate;

#define TYPE_ENTITY (entity_get_type ())

#define TYPE_ID (id_get_type ())
typedef struct _Id Id;

#define TYPE_NAME (name_get_type ())
typedef struct _Name Name;

#define TYPE_ACTIVE (active_get_type ())
typedef struct _Active Active;

#define TYPE_ACTOR_TYPE (actor_type_get_type ())

#define TYPE_ACTOR (actor_get_type ())
typedef struct _ActorType ActorType;

#define TYPE_ACTOR_STYLE (actor_style_get_type ())

#define TYPE_CATEGORY (category_get_type ())
typedef struct _ActorStyle ActorStyle;

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;

#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;

#define TYPE_SPRITE (sprite_get_type ())
typedef struct _Sprite Sprite;

#define TYPE_SOUND (sound_get_type ())
typedef struct _Sound Sound;

#define TYPE_COLOR (color_get_type ())
typedef struct _Color Color;

#define TYPE_DURATION (duration_get_type ())
typedef struct _Duration Duration;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;

#define TYPE_TWEEN (tween_get_type ())
typedef struct _Tween Tween;
typedef struct _Entity Entity;

#define TYPE_METRICS (metrics_get_type ())
typedef struct _Metrics Metrics;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_rand_free0(var) ((var == NULL) ? NULL : (var = (g_rand_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _Id {
	gint id;
};

struct _Name {
	gchar* name;
};

struct _Active {
	gboolean active;
};

typedef enum  {
	ACTOR_BACKGROUND,
	ACTOR_ENEMY1,
	ACTOR_ENEMY2,
	ACTOR_ENEMY3,
	ACTOR_PLAYER,
	ACTOR_BULLET,
	ACTOR_EXPLOSION,
	ACTOR_BANG,
	ACTOR_PARTICLE
} Actor;

struct _ActorType {
	Actor isA;
};

typedef enum  {
	CATEGORY_BACKGROUND,
	CATEGORY_BULLET,
	CATEGORY_ENEMY,
	CATEGORY_EXPLOSION,
	CATEGORY_PARTICLE,
	CATEGORY_PLAYER
} Category;

struct _ActorStyle {
	Category isA;
};

struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Vector2d {
	gdouble x;
	gdouble y;
};

struct _Sprite {
	SDL_Texture* texture;
	gint width;
	gint height;
};

struct _Sound {
	Mix_Chunk* effect;
};

struct _Color {
	gint r;
	gint g;
	gint b;
	gint a;
};

struct _Duration {
	gdouble timer;
};

struct _Health {
	gint current;
	gint maximum;
};

struct _Tween {
	gdouble min;
	gdouble max;
	gdouble speed;
	gboolean repeat;
	gboolean active;
};

struct _Entity {
	Id id;
	Name name;
	Active active;
	ActorType actor;
	ActorStyle style;
	Point2d position;
	SDL_Rect bounds;
	Vector2d scale;
	Sprite sprite;
	Sound* sound;
	Color* tint;
	Duration* expires;
	Health* health;
	Tween* tween;
	Vector2d* velocity;
};

struct _Metrics {
	gint bullet;
	gint enemy1;
	gint enemy2;
	gint enemy3;
	gint explosion;
	gint bang;
	gint particle;
	gint count;
};

struct _Game {
	GObject parent_instance;
	GamePrivate * priv;
	gchar* title;
	gint width;
	gint height;
	gint fps;
	gint mouseX;
	gint mouseY;
	gboolean mouseDown;
	gdouble delta;
	gdouble FireRate;
	gdouble timeToFire;
	gdouble enemyT1;
	gdouble enemyT2;
	gdouble enemyT3;
	GRand* rand;
	Entity* player;
	SDL_Window* window;
	SDL_Renderer* renderer;
	Entity* pool;
	gint pool_length1;
	guint8* keys;
	gint keys_length1;
	GeeArrayList* sprites;
	GeeArrayList* entity;
	GeeArrayList* unused;
	GeeArrayList* bullets;
	GeeArrayList* enemies1;
	GeeArrayList* enemies2;
	GeeArrayList* enemies3;
	GeeArrayList* explosions;
	GeeArrayList* bangs;
	GeeArrayList* particles;
	Metrics missing;
};

struct _GameClass {
	GObjectClass parent_class;
};

struct _GamePrivate {
	SDL_Event evt;
	gboolean _isRunning;
};


static gpointer game_parent_class = NULL;
extern gint factory_id;

#define COUNT_OF_BULLET 12
#define COUNT_OF_ENEMY1 15
#define COUNT_OF_ENEMY2 5
#define COUNT_OF_ENEMY3 4
#define COUNT_OF_EXPLOSION 10
#define COUNT_OF_BANG 12
#define COUNT_OF_PARTICLE 100
GType game_get_type (void) G_GNUC_CONST;
GType entity_get_type (void) G_GNUC_CONST;
GType id_get_type (void) G_GNUC_CONST;
Id* id_dup (const Id* self);
void id_free (Id* self);
GType name_get_type (void) G_GNUC_CONST;
Name* name_dup (const Name* self);
void name_free (Name* self);
void name_copy (const Name* self, Name* dest);
void name_destroy (Name* self);
GType active_get_type (void) G_GNUC_CONST;
Active* active_dup (const Active* self);
void active_free (Active* self);
GType actor_type_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
ActorType* actor_type_dup (const ActorType* self);
void actor_type_free (ActorType* self);
GType actor_style_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
ActorStyle* actor_style_dup (const ActorStyle* self);
void actor_style_free (ActorStyle* self);
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
GType sprite_get_type (void) G_GNUC_CONST;
Sprite* sprite_dup (const Sprite* self);
void sprite_free (Sprite* self);
GType sound_get_type (void) G_GNUC_CONST;
Sound* sound_dup (const Sound* self);
void sound_free (Sound* self);
GType color_get_type (void) G_GNUC_CONST;
Color* color_dup (const Color* self);
void color_free (Color* self);
GType duration_get_type (void) G_GNUC_CONST;
Duration* duration_dup (const Duration* self);
void duration_free (Duration* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
GType tween_get_type (void) G_GNUC_CONST;
Tween* tween_dup (const Tween* self);
void tween_free (Tween* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
GType metrics_get_type (void) G_GNUC_CONST;
Metrics* metrics_dup (const Metrics* self);
void metrics_free (Metrics* self);
#define GAME_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GAME, GamePrivate))
enum  {
	GAME_DUMMY_PROPERTY,
	GAME_UN_SATISFIED,
	GAME_IS_RUNNING
};
static void _vala_Entity_array_free (Entity * array, gint array_length);
void metrics_init (Metrics *self, gint bullet, gint enemy1, gint enemy2, gint enemy3, gint explosion, gint bang, gint particle, gint count);
Game* game_new (const gchar* title, gint width, gint height, SDL_Window* window, SDL_Renderer* renderer);
Game* game_construct (GType object_type, const gchar* title, gint width, gint height, SDL_Window* window, SDL_Renderer* renderer);
void game_init (Game* self);
void game_addSprite (Game* self, Entity* e);
Entity* createBackground (Game* game, Entity* pool, int pool_length1);
Entity* createPlayer (Game* game, Entity* pool, int pool_length1);
Entity* createBullet (Game* game, Entity* pool, int pool_length1);
Entity* createEnemy1 (Game* game, Entity* pool, int pool_length1);
Entity* createEnemy2 (Game* game, Entity* pool, int pool_length1);
Entity* createEnemy3 (Game* game, Entity* pool, int pool_length1);
Entity* createExplosion (Game* game, Entity* pool, int pool_length1);
Entity* createBang (Game* game, Entity* pool, int pool_length1);
Entity* createParticle (Game* game, Entity* pool, int pool_length1);
void game_removeSprite (Game* self, Entity* e);
void game_start (Game* self);
void game_stop (Game* self);
gboolean game_getKey (Game* self, gint key);
static void game_drawSprite (Game* self, Entity** e);
void game_draw (Game* self, gint fps, gdouble avg);
void game_handleEvents (Game* self);
void game_update (Game* self, gdouble delta);
void spawnSystem (Game* game, Entity** entity);
void collisionSystem (Game* game, Entity** entity);
void factorySystem (Game* game, Entity** entity);
gint game_get_unSatisfied (Game* self);
void game_updateMetrics (Game* self, gboolean abort);
void inputSystem (Game* game, Entity** entity);
void physicsSystem (Game* game, Entity** entity);
void expireSystem (Game* game, Entity** entity);
void tweenSystem (Game* game, Entity** entity);
void removeSystem (Game* game, Entity** entity);
void game_refresh (Game* self);
gboolean game_get_isRunning (Game* self);
static void game_finalize (GObject * obj);
static void _vala_game_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);


static void _vala_Entity_array_free (Entity * array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			entity_destroy (&array[i]);
		}
	}
	g_free (array);
}


Game* game_construct (GType object_type, const gchar* title, gint width, gint height, SDL_Window* window, SDL_Renderer* renderer) {
	Game * self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	SDL_Window* _tmp4_;
	SDL_Renderer* _tmp5_;
	GRand* _tmp6_;
	g_return_val_if_fail (title != NULL, NULL);
	g_return_val_if_fail (window != NULL, NULL);
	g_return_val_if_fail (renderer != NULL, NULL);
	self = (Game*) g_object_new (object_type, NULL);
	_tmp0_ = title;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->title);
	self->title = _tmp1_;
	_tmp2_ = width;
	self->width = _tmp2_;
	_tmp3_ = height;
	self->height = _tmp3_;
	_tmp4_ = window;
	self->window = _tmp4_;
	_tmp5_ = renderer;
	self->renderer = _tmp5_;
	_tmp6_ = g_rand_new ();
	_g_rand_free0 (self->rand);
	self->rand = _tmp6_;
	return self;
}


Game* game_new (const gchar* title, gint width, gint height, SDL_Window* window, SDL_Renderer* renderer) {
	return game_construct (TYPE_GAME, title, width, height, window, renderer);
}


/**
     * initialize the entity database
     */
void game_init (Game* self) {
	Entity* _tmp0_;
	Entity* _tmp1_;
	gint _tmp1__length1;
	Entity* _tmp2_;
	Entity* _tmp3_;
	gint _tmp3__length1;
	Entity* _tmp4_;
	Entity* _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_new0 (Entity, 256);
	self->pool = (_vala_Entity_array_free (self->pool, self->pool_length1), NULL);
	self->pool = _tmp0_;
	self->pool_length1 = 256;
	_tmp1_ = self->pool;
	_tmp1__length1 = self->pool_length1;
	_tmp2_ = createBackground (self, _tmp1_, _tmp1__length1);
	game_addSprite (self, _tmp2_);
	_tmp3_ = self->pool;
	_tmp3__length1 = self->pool_length1;
	_tmp4_ = createPlayer (self, _tmp3_, _tmp3__length1);
	self->player = _tmp4_;
	_tmp5_ = self->player;
	game_addSprite (self, _tmp5_);
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				Entity* _tmp8_;
				gint _tmp8__length1;
				if (!_tmp6_) {
					gint _tmp7_;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp6_ = FALSE;
				if (!(i <= COUNT_OF_BULLET)) {
					break;
				}
				_tmp8_ = self->pool;
				_tmp8__length1 = self->pool_length1;
				createBullet (self, _tmp8_, _tmp8__length1);
			}
		}
	}
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp9_ = FALSE;
			_tmp9_ = TRUE;
			while (TRUE) {
				Entity* _tmp11_;
				gint _tmp11__length1;
				if (!_tmp9_) {
					gint _tmp10_;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				if (!(i <= COUNT_OF_ENEMY1)) {
					break;
				}
				_tmp11_ = self->pool;
				_tmp11__length1 = self->pool_length1;
				createEnemy1 (self, _tmp11_, _tmp11__length1);
			}
		}
	}
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp12_ = FALSE;
			_tmp12_ = TRUE;
			while (TRUE) {
				Entity* _tmp14_;
				gint _tmp14__length1;
				if (!_tmp12_) {
					gint _tmp13_;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp12_ = FALSE;
				if (!(i <= COUNT_OF_ENEMY2)) {
					break;
				}
				_tmp14_ = self->pool;
				_tmp14__length1 = self->pool_length1;
				createEnemy2 (self, _tmp14_, _tmp14__length1);
			}
		}
	}
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp15_ = FALSE;
			_tmp15_ = TRUE;
			while (TRUE) {
				Entity* _tmp17_;
				gint _tmp17__length1;
				if (!_tmp15_) {
					gint _tmp16_;
					_tmp16_ = i;
					i = _tmp16_ + 1;
				}
				_tmp15_ = FALSE;
				if (!(i <= COUNT_OF_ENEMY3)) {
					break;
				}
				_tmp17_ = self->pool;
				_tmp17__length1 = self->pool_length1;
				createEnemy3 (self, _tmp17_, _tmp17__length1);
			}
		}
	}
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp18_ = FALSE;
			_tmp18_ = TRUE;
			while (TRUE) {
				Entity* _tmp20_;
				gint _tmp20__length1;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = i;
					i = _tmp19_ + 1;
				}
				_tmp18_ = FALSE;
				if (!(i <= COUNT_OF_EXPLOSION)) {
					break;
				}
				_tmp20_ = self->pool;
				_tmp20__length1 = self->pool_length1;
				createExplosion (self, _tmp20_, _tmp20__length1);
			}
		}
	}
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp21_ = FALSE;
			_tmp21_ = TRUE;
			while (TRUE) {
				Entity* _tmp23_;
				gint _tmp23__length1;
				if (!_tmp21_) {
					gint _tmp22_;
					_tmp22_ = i;
					i = _tmp22_ + 1;
				}
				_tmp21_ = FALSE;
				if (!(i <= COUNT_OF_BANG)) {
					break;
				}
				_tmp23_ = self->pool;
				_tmp23__length1 = self->pool_length1;
				createBang (self, _tmp23_, _tmp23__length1);
			}
		}
	}
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp24_ = FALSE;
			_tmp24_ = TRUE;
			while (TRUE) {
				Entity* _tmp26_;
				gint _tmp26__length1;
				if (!_tmp24_) {
					gint _tmp25_;
					_tmp25_ = i;
					i = _tmp25_ + 1;
				}
				_tmp24_ = FALSE;
				if (!(i <= COUNT_OF_PARTICLE)) {
					break;
				}
				_tmp26_ = self->pool;
				_tmp26__length1 = self->pool_length1;
				createParticle (self, _tmp26_, _tmp26__length1);
			}
		}
	}
}


/**
     * addSprite
     *
     * sort into actor enum ranking for layer display order
     *
     * @param entity to add
     */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void game_addSprite (Game* self, Entity* e) {
	gint rank = 0;
	Entity* _tmp0_;
	ActorType _tmp1_;
	Actor _tmp2_;
	GeeArrayList* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = e;
	_tmp1_ = (*_tmp0_).actor;
	_tmp2_ = _tmp1_.isA;
	rank = (gint) _tmp2_;
	_tmp3_ = self->sprites;
	_tmp4_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_ == 0) {
		GeeArrayList* _tmp6_;
		Entity* _tmp7_;
		_tmp6_ = self->sprites;
		_tmp7_ = e;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, _tmp7_);
	} else {
		gint i = 0;
		GeeArrayList* _tmp27_;
		Entity* _tmp28_;
		i = 0;
		{
			GeeArrayList* _s_list = NULL;
			GeeArrayList* _tmp8_;
			GeeArrayList* _tmp9_;
			gint _s_size = 0;
			GeeArrayList* _tmp10_;
			gint _tmp11_;
			gint _tmp12_;
			gint _s_index = 0;
			_tmp8_ = self->sprites;
			_tmp9_ = _g_object_ref0 (_tmp8_);
			_s_list = _tmp9_;
			_tmp10_ = _s_list;
			_tmp11_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp10_);
			_tmp12_ = _tmp11_;
			_s_size = _tmp12_;
			_s_index = -1;
			while (TRUE) {
				gint _tmp13_;
				gint _tmp14_;
				gint _tmp15_;
				Entity* s = NULL;
				GeeArrayList* _tmp16_;
				gint _tmp17_;
				gpointer _tmp18_;
				gint _tmp19_;
				Entity* _tmp20_;
				ActorType _tmp21_;
				Actor _tmp22_;
				_tmp13_ = _s_index;
				_s_index = _tmp13_ + 1;
				_tmp14_ = _s_index;
				_tmp15_ = _s_size;
				if (!(_tmp14_ < _tmp15_)) {
					break;
				}
				_tmp16_ = _s_list;
				_tmp17_ = _s_index;
				_tmp18_ = gee_abstract_list_get ((GeeAbstractList*) _tmp16_, _tmp17_);
				s = _tmp18_;
				_tmp19_ = rank;
				_tmp20_ = s;
				_tmp21_ = (*_tmp20_).actor;
				_tmp22_ = _tmp21_.isA;
				if (_tmp19_ <= ((gint) _tmp22_)) {
					GeeArrayList* _tmp23_;
					gint _tmp24_;
					Entity* _tmp25_;
					_tmp23_ = self->sprites;
					_tmp24_ = i;
					_tmp25_ = e;
					gee_abstract_list_insert ((GeeAbstractList*) _tmp23_, _tmp24_, _tmp25_);
					_g_object_unref0 (_s_list);
					return;
				} else {
					gint _tmp26_;
					_tmp26_ = i;
					i = _tmp26_ + 1;
				}
			}
			_g_object_unref0 (_s_list);
		}
		_tmp27_ = self->sprites;
		_tmp28_ = e;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp27_, _tmp28_);
	}
}


/**
     * removeSprite
     *
     * @param entity to remove
     */
void game_removeSprite (Game* self, Entity* e) {
	GeeArrayList* _tmp0_;
	Entity* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->sprites;
	_tmp1_ = e;
	gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp0_, _tmp1_);
}


/**
     * start
     */
void game_start (Game* self) {
	g_return_if_fail (self != NULL);
	game_init (self);
	self->priv->_isRunning = TRUE;
}


/**
     * stop
     */
void game_stop (Game* self) {
	Metrics _tmp0_;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	self->priv->_isRunning = FALSE;
	_tmp0_ = self->missing;
	_tmp1_ = _tmp0_.count;
	if (_tmp1_ > 0) {
		Metrics _tmp2_;
		gint _tmp3_;
		Metrics _tmp4_;
		gint _tmp5_;
		Metrics _tmp6_;
		gint _tmp7_;
		Metrics _tmp8_;
		gint _tmp9_;
		Metrics _tmp10_;
		gint _tmp11_;
		Metrics _tmp12_;
		gint _tmp13_;
		Metrics _tmp14_;
		gint _tmp15_;
		g_print ("====== Missing ======\n");
		_tmp2_ = self->missing;
		_tmp3_ = _tmp2_.bullet;
		g_print ("bullet: %d\n", _tmp3_);
		_tmp4_ = self->missing;
		_tmp5_ = _tmp4_.enemy1;
		g_print ("enemy1: %d\n", _tmp5_);
		_tmp6_ = self->missing;
		_tmp7_ = _tmp6_.enemy2;
		g_print ("enemy2: %d\n", _tmp7_);
		_tmp8_ = self->missing;
		_tmp9_ = _tmp8_.enemy3;
		g_print ("enemy3: %d\n", _tmp9_);
		_tmp10_ = self->missing;
		_tmp11_ = _tmp10_.explosion;
		g_print ("explosion: %d\n", _tmp11_);
		_tmp12_ = self->missing;
		_tmp13_ = _tmp12_.bang;
		g_print ("bang: %d\n", _tmp13_);
		_tmp14_ = self->missing;
		_tmp15_ = _tmp14_.particle;
		g_print ("particle: %d\n", _tmp15_);
	}
}


/**
     * getKey
     *
     * @param key to get
     * @returns bool true if key is pressed
     */
gboolean game_getKey (Game* self, gint key) {
	gboolean result = FALSE;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = key;
	if (_tmp0_ < 256) {
		guint8* _tmp1_;
		gint _tmp1__length1;
		gint _tmp2_;
		guint8 _tmp3_;
		_tmp1_ = self->keys;
		_tmp1__length1 = self->keys_length1;
		_tmp2_ = key;
		_tmp3_ = _tmp1_[_tmp2_];
		result = ((gint) _tmp3_) == 1;
		return result;
	}
	result = FALSE;
	return result;
}


/**
     * drawSprite
     *
     * @param entity to draw
     */
static void game_drawSprite (Game* self, Entity** e) {
	Entity* _tmp0_;
	ActorStyle _tmp1_;
	Category _tmp2_;
	SDL_Renderer* _tmp41_;
	Entity* _tmp42_;
	Sprite _tmp43_;
	SDL_Texture* _tmp44_;
	Entity* _tmp45_;
	SDL_Rect _tmp46_;
	g_return_if_fail (self != NULL);
	_tmp0_ = *e;
	_tmp1_ = (*_tmp0_).style;
	_tmp2_ = _tmp1_.isA;
	if (_tmp2_ != CATEGORY_BACKGROUND) {
		Entity* _tmp3_;
		Sprite _tmp4_;
		gint _tmp5_;
		Entity* _tmp6_;
		Vector2d _tmp7_;
		gdouble _tmp8_;
		Entity* _tmp9_;
		Sprite _tmp10_;
		gint _tmp11_;
		Entity* _tmp12_;
		Vector2d _tmp13_;
		gdouble _tmp14_;
		Entity* _tmp15_;
		Point2d _tmp16_;
		gdouble _tmp17_;
		Entity* _tmp18_;
		SDL_Rect _tmp19_;
		guint _tmp20_;
		Entity* _tmp21_;
		Point2d _tmp22_;
		gdouble _tmp23_;
		Entity* _tmp24_;
		SDL_Rect _tmp25_;
		guint _tmp26_;
		Entity* _tmp27_;
		Color* _tmp28_;
		_tmp3_ = *e;
		_tmp4_ = (*_tmp3_).sprite;
		_tmp5_ = _tmp4_.width;
		_tmp6_ = *e;
		_tmp7_ = (*_tmp6_).scale;
		_tmp8_ = _tmp7_.x;
		(*(*e)).bounds.w = (guint) ((gint) (((gdouble) _tmp5_) * _tmp8_));
		_tmp9_ = *e;
		_tmp10_ = (*_tmp9_).sprite;
		_tmp11_ = _tmp10_.height;
		_tmp12_ = *e;
		_tmp13_ = (*_tmp12_).scale;
		_tmp14_ = _tmp13_.y;
		(*(*e)).bounds.h = (guint) ((gint) (((gdouble) _tmp11_) * _tmp14_));
		_tmp15_ = *e;
		_tmp16_ = (*_tmp15_).position;
		_tmp17_ = _tmp16_.x;
		_tmp18_ = *e;
		_tmp19_ = (*_tmp18_).bounds;
		_tmp20_ = _tmp19_.w;
		(*(*e)).bounds.x = (gint) (((gdouble) _tmp17_) - (_tmp20_ / 2));
		_tmp21_ = *e;
		_tmp22_ = (*_tmp21_).position;
		_tmp23_ = _tmp22_.y;
		_tmp24_ = *e;
		_tmp25_ = (*_tmp24_).bounds;
		_tmp26_ = _tmp25_.h;
		(*(*e)).bounds.y = (gint) (((gdouble) _tmp23_) - (_tmp26_ / 2));
		_tmp27_ = *e;
		_tmp28_ = (*_tmp27_).tint;
		if (_tmp28_ != NULL) {
			Entity* _tmp29_;
			Sprite _tmp30_;
			SDL_Texture* _tmp31_;
			Entity* _tmp32_;
			Color* _tmp33_;
			gint _tmp34_;
			Entity* _tmp35_;
			Color* _tmp36_;
			gint _tmp37_;
			Entity* _tmp38_;
			Color* _tmp39_;
			gint _tmp40_;
			_tmp29_ = *e;
			_tmp30_ = (*_tmp29_).sprite;
			_tmp31_ = _tmp30_.texture;
			_tmp32_ = *e;
			_tmp33_ = (*_tmp32_).tint;
			_tmp34_ = (*_tmp33_).r;
			_tmp35_ = *e;
			_tmp36_ = (*_tmp35_).tint;
			_tmp37_ = (*_tmp36_).g;
			_tmp38_ = *e;
			_tmp39_ = (*_tmp38_).tint;
			_tmp40_ = (*_tmp39_).b;
			SDL_SetTextureColorMod (_tmp31_, (guint8) _tmp34_, (guint8) _tmp37_, (guint8) _tmp40_);
		}
	}
	_tmp41_ = self->renderer;
	_tmp42_ = *e;
	_tmp43_ = (*_tmp42_).sprite;
	_tmp44_ = _tmp43_.texture;
	_tmp45_ = *e;
	_tmp46_ = (*_tmp45_).bounds;
	SDL_RenderCopy (_tmp41_, _tmp44_, NULL, &_tmp46_);
}


/**
     * draw the frame
     *
     * @param fps - frames per second
     * @param avg - average time consumed per frame
     */
void game_draw (Game* self, gint fps, gdouble avg) {
	SDL_Renderer* _tmp0_;
	SDL_Renderer* _tmp1_;
	SDL_Renderer* _tmp16_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->renderer;
	SDL_SetRenderDrawColor (_tmp0_, (guint8) 0x0, (guint8) 0x0, (guint8) 0x0, (guint8) 0x0);
	_tmp1_ = self->renderer;
	SDL_RenderClear (_tmp1_);
	{
		GeeArrayList* _e_list = NULL;
		GeeArrayList* _tmp2_;
		GeeArrayList* _tmp3_;
		gint _e_size = 0;
		GeeArrayList* _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		gint _e_index = 0;
		_tmp2_ = self->sprites;
		_tmp3_ = _g_object_ref0 (_tmp2_);
		_e_list = _tmp3_;
		_tmp4_ = _e_list;
		_tmp5_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		_e_size = _tmp6_;
		_e_index = -1;
		while (TRUE) {
			gint _tmp7_;
			gint _tmp8_;
			gint _tmp9_;
			Entity* e = NULL;
			GeeArrayList* _tmp10_;
			gint _tmp11_;
			gpointer _tmp12_;
			Entity* _tmp13_;
			Active _tmp14_;
			gboolean _tmp15_;
			_tmp7_ = _e_index;
			_e_index = _tmp7_ + 1;
			_tmp8_ = _e_index;
			_tmp9_ = _e_size;
			if (!(_tmp8_ < _tmp9_)) {
				break;
			}
			_tmp10_ = _e_list;
			_tmp11_ = _e_index;
			_tmp12_ = gee_abstract_list_get ((GeeAbstractList*) _tmp10_, _tmp11_);
			e = _tmp12_;
			_tmp13_ = e;
			_tmp14_ = (*_tmp13_).active;
			_tmp15_ = _tmp14_.active;
			if (_tmp15_) {
				game_drawSprite (self, &e);
			}
		}
		_g_object_unref0 (_e_list);
	}
	_tmp16_ = self->renderer;
	SDL_RenderPresent (_tmp16_);
}


/**
     * handleEvents
     */
void game_handleEvents (Game* self) {
	g_return_if_fail (self != NULL);
	while (TRUE) {
		SDL_Event _tmp0_ = {0};
		gint _tmp1_;
		SDL_Event _tmp2_;
		SDL_EventType _tmp3_;
		_tmp1_ = SDL_PollEvent (&_tmp0_);
		 (self->priv->evt);
		self->priv->evt = _tmp0_;
		if (!(_tmp1_ != 0)) {
			break;
		}
		_tmp2_ = self->priv->evt;
		_tmp3_ = _tmp2_.type;
		switch (_tmp3_) {
			case SDL_KEYDOWN:
			{
				{
					SDL_Event _tmp4_;
					SDL_KeyboardEvent _tmp5_;
					SDL_Keysym _tmp6_;
					SDL_Keycode _tmp7_;
					_tmp4_ = self->priv->evt;
					_tmp5_ = _tmp4_.key;
					_tmp6_ = _tmp5_.keysym;
					_tmp7_ = _tmp6_.sym;
					if (_tmp7_ <= 255) {
						guint8* _tmp8_;
						gint _tmp8__length1;
						SDL_Event _tmp9_;
						SDL_KeyboardEvent _tmp10_;
						SDL_Keysym _tmp11_;
						SDL_Keycode _tmp12_;
						guint8 _tmp13_;
						_tmp8_ = self->keys;
						_tmp8__length1 = self->keys_length1;
						_tmp9_ = self->priv->evt;
						_tmp10_ = _tmp9_.key;
						_tmp11_ = _tmp10_.keysym;
						_tmp12_ = _tmp11_.sym;
						_tmp8_[_tmp12_] = (guint8) 1;
						_tmp13_ = _tmp8_[_tmp12_];
					}
				}
				break;
			}
			case SDL_KEYUP:
			{
				{
					SDL_Event _tmp14_;
					SDL_KeyboardEvent _tmp15_;
					SDL_Keysym _tmp16_;
					SDL_Keycode _tmp17_;
					_tmp14_ = self->priv->evt;
					_tmp15_ = _tmp14_.key;
					_tmp16_ = _tmp15_.keysym;
					_tmp17_ = _tmp16_.sym;
					if (_tmp17_ <= 255) {
						guint8* _tmp18_;
						gint _tmp18__length1;
						SDL_Event _tmp19_;
						SDL_KeyboardEvent _tmp20_;
						SDL_Keysym _tmp21_;
						SDL_Keycode _tmp22_;
						guint8 _tmp23_;
						_tmp18_ = self->keys;
						_tmp18__length1 = self->keys_length1;
						_tmp19_ = self->priv->evt;
						_tmp20_ = _tmp19_.key;
						_tmp21_ = _tmp20_.keysym;
						_tmp22_ = _tmp21_.sym;
						_tmp18_[_tmp22_] = (guint8) 0;
						_tmp23_ = _tmp18_[_tmp22_];
					}
				}
				break;
			}
			case SDL_MOUSEMOTION:
			{
				{
					SDL_Event _tmp24_;
					SDL_MouseMotionEvent _tmp25_;
					gint32 _tmp26_;
					SDL_Event _tmp27_;
					SDL_MouseMotionEvent _tmp28_;
					gint32 _tmp29_;
					_tmp24_ = self->priv->evt;
					_tmp25_ = _tmp24_.motion;
					_tmp26_ = _tmp25_.x;
					self->mouseX = (gint) _tmp26_;
					_tmp27_ = self->priv->evt;
					_tmp28_ = _tmp27_.motion;
					_tmp29_ = _tmp28_.y;
					self->mouseY = (gint) _tmp29_;
				}
				break;
			}
			case SDL_MOUSEBUTTONDOWN:
			{
				{
					self->mouseDown = TRUE;
				}
				break;
			}
			case SDL_MOUSEBUTTONUP:
			{
				{
					self->mouseDown = FALSE;
				}
				break;
			}
			case SDL_QUIT:
			{
				{
					game_stop (self);
				}
				break;
			}
			default:
			break;
		}
	}
}


/**
     * update
     *
     * @param delta time
     */
void game_update (Game* self, gdouble delta) {
	gdouble _tmp0_;
	gint _tmp23_;
	gint _tmp24_;
	g_return_if_fail (self != NULL);
	_tmp0_ = delta;
	self->delta = _tmp0_;
	spawnSystem (self, &self->player);
	{
		GeeArrayList* _e_list = NULL;
		GeeArrayList* _tmp1_;
		GeeArrayList* _tmp2_;
		gint _e_size = 0;
		GeeArrayList* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		gint _e_index = 0;
		_tmp1_ = self->entity;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_e_list = _tmp2_;
		_tmp3_ = _e_list;
		_tmp4_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp3_);
		_tmp5_ = _tmp4_;
		_e_size = _tmp5_;
		_e_index = -1;
		while (TRUE) {
			gint _tmp6_;
			gint _tmp7_;
			gint _tmp8_;
			Entity* e = NULL;
			GeeArrayList* _tmp9_;
			gint _tmp10_;
			gpointer _tmp11_;
			_tmp6_ = _e_index;
			_e_index = _tmp6_ + 1;
			_tmp7_ = _e_index;
			_tmp8_ = _e_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _e_list;
			_tmp10_ = _e_index;
			_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, _tmp10_);
			e = _tmp11_;
			collisionSystem (self, &e);
		}
		_g_object_unref0 (_e_list);
	}
	{
		GeeArrayList* _e_list = NULL;
		GeeArrayList* _tmp12_;
		GeeArrayList* _tmp13_;
		gint _e_size = 0;
		GeeArrayList* _tmp14_;
		gint _tmp15_;
		gint _tmp16_;
		gint _e_index = 0;
		_tmp12_ = self->unused;
		_tmp13_ = _g_object_ref0 (_tmp12_);
		_e_list = _tmp13_;
		_tmp14_ = _e_list;
		_tmp15_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp14_);
		_tmp16_ = _tmp15_;
		_e_size = _tmp16_;
		_e_index = -1;
		while (TRUE) {
			gint _tmp17_;
			gint _tmp18_;
			gint _tmp19_;
			Entity* e = NULL;
			GeeArrayList* _tmp20_;
			gint _tmp21_;
			gpointer _tmp22_;
			_tmp17_ = _e_index;
			_e_index = _tmp17_ + 1;
			_tmp18_ = _e_index;
			_tmp19_ = _e_size;
			if (!(_tmp18_ < _tmp19_)) {
				break;
			}
			_tmp20_ = _e_list;
			_tmp21_ = _e_index;
			_tmp22_ = gee_abstract_list_get ((GeeAbstractList*) _tmp20_, _tmp21_);
			e = _tmp22_;
			factorySystem (self, &e);
		}
		_g_object_unref0 (_e_list);
	}
	_tmp23_ = game_get_unSatisfied (self);
	_tmp24_ = _tmp23_;
	if (_tmp24_ > 0) {
		game_updateMetrics (self, TRUE);
	}
	inputSystem (self, &self->player);
	{
		GeeArrayList* _e_list = NULL;
		GeeArrayList* _tmp25_;
		GeeArrayList* _tmp26_;
		gint _e_size = 0;
		GeeArrayList* _tmp27_;
		gint _tmp28_;
		gint _tmp29_;
		gint _e_index = 0;
		_tmp25_ = self->entity;
		_tmp26_ = _g_object_ref0 (_tmp25_);
		_e_list = _tmp26_;
		_tmp27_ = _e_list;
		_tmp28_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp27_);
		_tmp29_ = _tmp28_;
		_e_size = _tmp29_;
		_e_index = -1;
		while (TRUE) {
			gint _tmp30_;
			gint _tmp31_;
			gint _tmp32_;
			Entity* e = NULL;
			GeeArrayList* _tmp33_;
			gint _tmp34_;
			gpointer _tmp35_;
			_tmp30_ = _e_index;
			_e_index = _tmp30_ + 1;
			_tmp31_ = _e_index;
			_tmp32_ = _e_size;
			if (!(_tmp31_ < _tmp32_)) {
				break;
			}
			_tmp33_ = _e_list;
			_tmp34_ = _e_index;
			_tmp35_ = gee_abstract_list_get ((GeeAbstractList*) _tmp33_, _tmp34_);
			e = _tmp35_;
			physicsSystem (self, &e);
		}
		_g_object_unref0 (_e_list);
	}
	{
		GeeArrayList* _e_list = NULL;
		GeeArrayList* _tmp36_;
		GeeArrayList* _tmp37_;
		gint _e_size = 0;
		GeeArrayList* _tmp38_;
		gint _tmp39_;
		gint _tmp40_;
		gint _e_index = 0;
		_tmp36_ = self->entity;
		_tmp37_ = _g_object_ref0 (_tmp36_);
		_e_list = _tmp37_;
		_tmp38_ = _e_list;
		_tmp39_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp38_);
		_tmp40_ = _tmp39_;
		_e_size = _tmp40_;
		_e_index = -1;
		while (TRUE) {
			gint _tmp41_;
			gint _tmp42_;
			gint _tmp43_;
			Entity* e = NULL;
			GeeArrayList* _tmp44_;
			gint _tmp45_;
			gpointer _tmp46_;
			_tmp41_ = _e_index;
			_e_index = _tmp41_ + 1;
			_tmp42_ = _e_index;
			_tmp43_ = _e_size;
			if (!(_tmp42_ < _tmp43_)) {
				break;
			}
			_tmp44_ = _e_list;
			_tmp45_ = _e_index;
			_tmp46_ = gee_abstract_list_get ((GeeAbstractList*) _tmp44_, _tmp45_);
			e = _tmp46_;
			expireSystem (self, &e);
		}
		_g_object_unref0 (_e_list);
	}
	{
		GeeArrayList* _e_list = NULL;
		GeeArrayList* _tmp47_;
		GeeArrayList* _tmp48_;
		gint _e_size = 0;
		GeeArrayList* _tmp49_;
		gint _tmp50_;
		gint _tmp51_;
		gint _e_index = 0;
		_tmp47_ = self->entity;
		_tmp48_ = _g_object_ref0 (_tmp47_);
		_e_list = _tmp48_;
		_tmp49_ = _e_list;
		_tmp50_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp49_);
		_tmp51_ = _tmp50_;
		_e_size = _tmp51_;
		_e_index = -1;
		while (TRUE) {
			gint _tmp52_;
			gint _tmp53_;
			gint _tmp54_;
			Entity* e = NULL;
			GeeArrayList* _tmp55_;
			gint _tmp56_;
			gpointer _tmp57_;
			_tmp52_ = _e_index;
			_e_index = _tmp52_ + 1;
			_tmp53_ = _e_index;
			_tmp54_ = _e_size;
			if (!(_tmp53_ < _tmp54_)) {
				break;
			}
			_tmp55_ = _e_list;
			_tmp56_ = _e_index;
			_tmp57_ = gee_abstract_list_get ((GeeAbstractList*) _tmp55_, _tmp56_);
			e = _tmp57_;
			tweenSystem (self, &e);
		}
		_g_object_unref0 (_e_list);
	}
	{
		GeeArrayList* _e_list = NULL;
		GeeArrayList* _tmp58_;
		GeeArrayList* _tmp59_;
		gint _e_size = 0;
		GeeArrayList* _tmp60_;
		gint _tmp61_;
		gint _tmp62_;
		gint _e_index = 0;
		_tmp58_ = self->entity;
		_tmp59_ = _g_object_ref0 (_tmp58_);
		_e_list = _tmp59_;
		_tmp60_ = _e_list;
		_tmp61_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp60_);
		_tmp62_ = _tmp61_;
		_e_size = _tmp62_;
		_e_index = -1;
		while (TRUE) {
			gint _tmp63_;
			gint _tmp64_;
			gint _tmp65_;
			Entity* e = NULL;
			GeeArrayList* _tmp66_;
			gint _tmp67_;
			gpointer _tmp68_;
			_tmp63_ = _e_index;
			_e_index = _tmp63_ + 1;
			_tmp64_ = _e_index;
			_tmp65_ = _e_size;
			if (!(_tmp64_ < _tmp65_)) {
				break;
			}
			_tmp66_ = _e_list;
			_tmp67_ = _e_index;
			_tmp68_ = gee_abstract_list_get ((GeeAbstractList*) _tmp66_, _tmp67_);
			e = _tmp68_;
			removeSystem (self, &e);
		}
		_g_object_unref0 (_e_list);
	}
}


/**
     * refresh the entity database pointers
     */
void game_refresh (Game* self) {
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->entity;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
	_tmp1_ = self->unused;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp1_);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_;
				Entity* _tmp5_;
				gint _tmp5__length1;
				gint _tmp6_;
				Entity _tmp7_;
				Active _tmp8_;
				gboolean _tmp9_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = factory_id;
				if (!(i <= (_tmp4_ - 1))) {
					break;
				}
				_tmp5_ = self->pool;
				_tmp5__length1 = self->pool_length1;
				_tmp6_ = i;
				_tmp7_ = _tmp5_[_tmp6_];
				_tmp8_ = _tmp7_.active;
				_tmp9_ = _tmp8_.active;
				if (_tmp9_) {
					GeeArrayList* _tmp10_;
					Entity* _tmp11_;
					gint _tmp11__length1;
					gint _tmp12_;
					_tmp10_ = self->entity;
					_tmp11_ = self->pool;
					_tmp11__length1 = self->pool_length1;
					_tmp12_ = i;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, &_tmp11_[_tmp12_]);
				} else {
					GeeArrayList* _tmp13_;
					Entity* _tmp14_;
					gint _tmp14__length1;
					gint _tmp15_;
					_tmp13_ = self->unused;
					_tmp14_ = self->pool;
					_tmp14__length1 = self->pool_length1;
					_tmp15_ = i;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp13_, &_tmp14_[_tmp15_]);
				}
			}
		}
	}
}


void game_updateMetrics (Game* self, gboolean abort) {
	gint _tmp0_;
	gint _tmp1_;
	Metrics _tmp2_;
	gint _tmp3_;
	GeeArrayList* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	GeeArrayList* _tmp17_;
	gint _tmp18_;
	gint _tmp19_;
	GeeArrayList* _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	GeeArrayList* _tmp39_;
	gint _tmp40_;
	gint _tmp41_;
	GeeArrayList* _tmp50_;
	gint _tmp51_;
	gint _tmp52_;
	GeeArrayList* _tmp61_;
	gint _tmp62_;
	gint _tmp63_;
	GeeArrayList* _tmp72_;
	gint _tmp73_;
	gint _tmp74_;
	g_return_if_fail (self != NULL);
	_tmp0_ = game_get_unSatisfied (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->missing;
	_tmp3_ = _tmp2_.count;
	if (_tmp1_ > _tmp3_) {
		gint _tmp4_;
		gint _tmp5_;
		_tmp4_ = game_get_unSatisfied (self);
		_tmp5_ = _tmp4_;
		self->missing.count = _tmp5_;
	}
	_tmp6_ = self->bullets;
	_tmp7_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp6_);
	_tmp8_ = _tmp7_;
	if (_tmp8_ > 0) {
		GeeArrayList* _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		Metrics _tmp12_;
		gint _tmp13_;
		_tmp9_ = self->bullets;
		_tmp10_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = self->missing;
		_tmp13_ = _tmp12_.bullet;
		if (_tmp11_ > _tmp13_) {
			GeeArrayList* _tmp14_;
			gint _tmp15_;
			gint _tmp16_;
			_tmp14_ = self->bullets;
			_tmp15_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp14_);
			_tmp16_ = _tmp15_;
			self->missing.bullet = _tmp16_;
		}
	}
	_tmp17_ = self->enemies1;
	_tmp18_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp17_);
	_tmp19_ = _tmp18_;
	if (_tmp19_ > 0) {
		GeeArrayList* _tmp20_;
		gint _tmp21_;
		gint _tmp22_;
		Metrics _tmp23_;
		gint _tmp24_;
		_tmp20_ = self->enemies1;
		_tmp21_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = self->missing;
		_tmp24_ = _tmp23_.enemy1;
		if (_tmp22_ > _tmp24_) {
			GeeArrayList* _tmp25_;
			gint _tmp26_;
			gint _tmp27_;
			_tmp25_ = self->enemies1;
			_tmp26_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp25_);
			_tmp27_ = _tmp26_;
			self->missing.enemy1 = _tmp27_;
		}
	}
	_tmp28_ = self->enemies2;
	_tmp29_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp28_);
	_tmp30_ = _tmp29_;
	if (_tmp30_ > 0) {
		GeeArrayList* _tmp31_;
		gint _tmp32_;
		gint _tmp33_;
		Metrics _tmp34_;
		gint _tmp35_;
		_tmp31_ = self->enemies2;
		_tmp32_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp31_);
		_tmp33_ = _tmp32_;
		_tmp34_ = self->missing;
		_tmp35_ = _tmp34_.enemy2;
		if (_tmp33_ > _tmp35_) {
			GeeArrayList* _tmp36_;
			gint _tmp37_;
			gint _tmp38_;
			_tmp36_ = self->enemies2;
			_tmp37_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp36_);
			_tmp38_ = _tmp37_;
			self->missing.enemy2 = _tmp38_;
		}
	}
	_tmp39_ = self->enemies3;
	_tmp40_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp39_);
	_tmp41_ = _tmp40_;
	if (_tmp41_ > 0) {
		GeeArrayList* _tmp42_;
		gint _tmp43_;
		gint _tmp44_;
		Metrics _tmp45_;
		gint _tmp46_;
		_tmp42_ = self->enemies3;
		_tmp43_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp42_);
		_tmp44_ = _tmp43_;
		_tmp45_ = self->missing;
		_tmp46_ = _tmp45_.enemy3;
		if (_tmp44_ > _tmp46_) {
			GeeArrayList* _tmp47_;
			gint _tmp48_;
			gint _tmp49_;
			_tmp47_ = self->enemies3;
			_tmp48_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp47_);
			_tmp49_ = _tmp48_;
			self->missing.enemy3 = _tmp49_;
		}
	}
	_tmp50_ = self->explosions;
	_tmp51_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp50_);
	_tmp52_ = _tmp51_;
	if (_tmp52_ > 0) {
		GeeArrayList* _tmp53_;
		gint _tmp54_;
		gint _tmp55_;
		Metrics _tmp56_;
		gint _tmp57_;
		_tmp53_ = self->explosions;
		_tmp54_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp53_);
		_tmp55_ = _tmp54_;
		_tmp56_ = self->missing;
		_tmp57_ = _tmp56_.explosion;
		if (_tmp55_ > _tmp57_) {
			GeeArrayList* _tmp58_;
			gint _tmp59_;
			gint _tmp60_;
			_tmp58_ = self->explosions;
			_tmp59_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp58_);
			_tmp60_ = _tmp59_;
			self->missing.explosion = _tmp60_;
		}
	}
	_tmp61_ = self->bangs;
	_tmp62_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp61_);
	_tmp63_ = _tmp62_;
	if (_tmp63_ > 0) {
		GeeArrayList* _tmp64_;
		gint _tmp65_;
		gint _tmp66_;
		Metrics _tmp67_;
		gint _tmp68_;
		_tmp64_ = self->bangs;
		_tmp65_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp64_);
		_tmp66_ = _tmp65_;
		_tmp67_ = self->missing;
		_tmp68_ = _tmp67_.bang;
		if (_tmp66_ > _tmp68_) {
			GeeArrayList* _tmp69_;
			gint _tmp70_;
			gint _tmp71_;
			_tmp69_ = self->bangs;
			_tmp70_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp69_);
			_tmp71_ = _tmp70_;
			self->missing.bang = _tmp71_;
		}
	}
	_tmp72_ = self->particles;
	_tmp73_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp72_);
	_tmp74_ = _tmp73_;
	if (_tmp74_ > 0) {
		GeeArrayList* _tmp75_;
		gint _tmp76_;
		gint _tmp77_;
		Metrics _tmp78_;
		gint _tmp79_;
		_tmp75_ = self->particles;
		_tmp76_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp75_);
		_tmp77_ = _tmp76_;
		_tmp78_ = self->missing;
		_tmp79_ = _tmp78_.particle;
		if (_tmp77_ > _tmp79_) {
			GeeArrayList* _tmp80_;
			gint _tmp81_;
			gint _tmp82_;
			_tmp80_ = self->particles;
			_tmp81_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp80_);
			_tmp82_ = _tmp81_;
			self->missing.particle = _tmp82_;
		}
	}
}


gint game_get_unSatisfied (Game* self) {
	gint result;
	GeeArrayList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	GeeArrayList* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	GeeArrayList* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	GeeArrayList* _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	GeeArrayList* _tmp12_;
	gint _tmp13_;
	gint _tmp14_;
	GeeArrayList* _tmp15_;
	gint _tmp16_;
	gint _tmp17_;
	GeeArrayList* _tmp18_;
	gint _tmp19_;
	gint _tmp20_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->bullets;
	_tmp1_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->enemies1;
	_tmp4_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = self->enemies2;
	_tmp7_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = self->enemies3;
	_tmp10_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = self->explosions;
	_tmp13_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = self->bangs;
	_tmp16_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = self->particles;
	_tmp19_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp18_);
	_tmp20_ = _tmp19_;
	result = (((((_tmp2_ + _tmp5_) + _tmp8_) + _tmp11_) + _tmp14_) + _tmp17_) + _tmp20_;
	return result;
}


gboolean game_get_isRunning (Game* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_isRunning;
	result = _tmp0_;
	return result;
}


static void game_class_init (GameClass * klass) {
	game_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GamePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_game_get_property;
	G_OBJECT_CLASS (klass)->finalize = game_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GAME_UN_SATISFIED, g_param_spec_int ("unSatisfied", "unSatisfied", "unSatisfied", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GAME_IS_RUNNING, g_param_spec_boolean ("isRunning", "isRunning", "isRunning", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void game_instance_init (Game * self) {
	guint8* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	GeeArrayList* _tmp4_;
	GeeArrayList* _tmp5_;
	GeeArrayList* _tmp6_;
	GeeArrayList* _tmp7_;
	GeeArrayList* _tmp8_;
	GeeArrayList* _tmp9_;
	GeeArrayList* _tmp10_;
	self->priv = GAME_GET_PRIVATE (self);
	self->width = 0;
	self->height = 0;
	self->fps = 0;
	self->mouseX = 0;
	self->mouseY = 0;
	self->mouseDown = FALSE;
	self->delta = 0.0;
	self->FireRate = 0.1;
	self->timeToFire = 0.0;
	self->enemyT1 = 1.0;
	self->enemyT2 = 4.0;
	self->enemyT3 = 6.0;
	_tmp0_ = g_new0 (guint8, 255);
	self->keys = _tmp0_;
	self->keys_length1 = 255;
	_tmp1_ = gee_array_list_new (G_TYPE_POINTER, NULL, NULL, NULL, NULL, NULL);
	self->sprites = _tmp1_;
	_tmp2_ = gee_array_list_new (G_TYPE_POINTER, NULL, NULL, NULL, NULL, NULL);
	self->entity = _tmp2_;
	_tmp3_ = gee_array_list_new (G_TYPE_POINTER, NULL, NULL, NULL, NULL, NULL);
	self->unused = _tmp3_;
	_tmp4_ = gee_array_list_new (TYPE_POINT2D, (GBoxedCopyFunc) point2d_dup, (GDestroyNotify) point2d_free, NULL, NULL, NULL);
	self->bullets = _tmp4_;
	_tmp5_ = gee_array_list_new (TYPE_POINT2D, (GBoxedCopyFunc) point2d_dup, (GDestroyNotify) point2d_free, NULL, NULL, NULL);
	self->enemies1 = _tmp5_;
	_tmp6_ = gee_array_list_new (TYPE_POINT2D, (GBoxedCopyFunc) point2d_dup, (GDestroyNotify) point2d_free, NULL, NULL, NULL);
	self->enemies2 = _tmp6_;
	_tmp7_ = gee_array_list_new (TYPE_POINT2D, (GBoxedCopyFunc) point2d_dup, (GDestroyNotify) point2d_free, NULL, NULL, NULL);
	self->enemies3 = _tmp7_;
	_tmp8_ = gee_array_list_new (TYPE_POINT2D, (GBoxedCopyFunc) point2d_dup, (GDestroyNotify) point2d_free, NULL, NULL, NULL);
	self->explosions = _tmp8_;
	_tmp9_ = gee_array_list_new (TYPE_POINT2D, (GBoxedCopyFunc) point2d_dup, (GDestroyNotify) point2d_free, NULL, NULL, NULL);
	self->bangs = _tmp9_;
	_tmp10_ = gee_array_list_new (TYPE_POINT2D, (GBoxedCopyFunc) point2d_dup, (GDestroyNotify) point2d_free, NULL, NULL, NULL);
	self->particles = _tmp10_;
	metrics_init (&self->missing, 0, 0, 0, 0, 0, 0, 0, 0);
}


static void game_finalize (GObject * obj) {
	Game * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_GAME, Game);
	_g_free0 (self->title);
	_g_rand_free0 (self->rand);
	 (self->priv->evt);
	self->pool = (_vala_Entity_array_free (self->pool, self->pool_length1), NULL);
	self->keys = (g_free (self->keys), NULL);
	_g_object_unref0 (self->sprites);
	_g_object_unref0 (self->entity);
	_g_object_unref0 (self->unused);
	_g_object_unref0 (self->bullets);
	_g_object_unref0 (self->enemies1);
	_g_object_unref0 (self->enemies2);
	_g_object_unref0 (self->enemies3);
	_g_object_unref0 (self->explosions);
	_g_object_unref0 (self->bangs);
	_g_object_unref0 (self->particles);
	G_OBJECT_CLASS (game_parent_class)->finalize (obj);
}


GType game_get_type (void) {
	static volatile gsize game_type_id__volatile = 0;
	if (g_once_init_enter (&game_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GameClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) game_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Game), 0, (GInstanceInitFunc) game_instance_init, NULL };
		GType game_type_id;
		game_type_id = g_type_register_static (G_TYPE_OBJECT, "Game", &g_define_type_info, 0);
		g_once_init_leave (&game_type_id__volatile, game_type_id);
	}
	return game_type_id__volatile;
}


static void _vala_game_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Game * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_GAME, Game);
	switch (property_id) {
		case GAME_UN_SATISFIED:
		g_value_set_int (value, game_get_unSatisfied (self));
		break;
		case GAME_IS_RUNNING:
		g_value_set_boolean (value, game_get_isRunning (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



