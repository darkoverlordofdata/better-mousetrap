/* systems.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from systems.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <SDL2/SDL_rect.h>
#include <SDL2/SDL_render.h>
#include <SDL2/SDL_mixer.h>
#include <SDL2/SDL_video.h>
#include <gee.h>


#define TYPE_GAME (game_get_type ())
#define GAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME, Game))
#define GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME, GameClass))
#define IS_GAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME))
#define IS_GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME))
#define GAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME, GameClass))

typedef struct _Game Game;
typedef struct _GameClass GameClass;

#define TYPE_ENTITY (entity_get_type ())

#define TYPE_ID (id_get_type ())
typedef struct _Id Id;

#define TYPE_NAME (name_get_type ())
typedef struct _Name Name;

#define TYPE_ACTIVE (active_get_type ())
typedef struct _Active Active;

#define TYPE_ACTOR_TYPE (actor_type_get_type ())

#define TYPE_ACTOR (actor_get_type ())
typedef struct _ActorType ActorType;

#define TYPE_ACTOR_STYLE (actor_style_get_type ())

#define TYPE_CATEGORY (category_get_type ())
typedef struct _ActorStyle ActorStyle;

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;

#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;

#define TYPE_SPRITE (sprite_get_type ())
typedef struct _Sprite Sprite;

#define TYPE_SOUND (sound_get_type ())
typedef struct _Sound Sound;

#define TYPE_COLOR (color_get_type ())
typedef struct _Color Color;

#define TYPE_DURATION (duration_get_type ())
typedef struct _Duration Duration;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;

#define TYPE_TWEEN (tween_get_type ())
typedef struct _Tween Tween;
typedef struct _Entity Entity;
typedef struct _GamePrivate GamePrivate;

#define TYPE_METRICS (metrics_get_type ())
typedef struct _Metrics Metrics;
#define _point2d_free0(var) ((var == NULL) ? NULL : (var = (point2d_free (var), NULL)))
#define _health_free0(var) ((var == NULL) ? NULL : (var = (health_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _Id {
	gint id;
};

struct _Name {
	gchar* name;
};

struct _Active {
	gboolean active;
};

typedef enum  {
	ACTOR_BACKGROUND,
	ACTOR_ENEMY1,
	ACTOR_ENEMY2,
	ACTOR_ENEMY3,
	ACTOR_PLAYER,
	ACTOR_BULLET,
	ACTOR_EXPLOSION,
	ACTOR_BANG,
	ACTOR_PARTICLE
} Actor;

struct _ActorType {
	Actor isA;
};

typedef enum  {
	CATEGORY_BACKGROUND,
	CATEGORY_BULLET,
	CATEGORY_ENEMY,
	CATEGORY_EXPLOSION,
	CATEGORY_PARTICLE,
	CATEGORY_PLAYER
} Category;

struct _ActorStyle {
	Category isA;
};

struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Vector2d {
	gdouble x;
	gdouble y;
};

struct _Sprite {
	SDL_Texture* texture;
	gint width;
	gint height;
};

struct _Sound {
	Mix_Chunk* effect;
};

struct _Color {
	gint r;
	gint g;
	gint b;
	gint a;
};

struct _Duration {
	gdouble timer;
};

struct _Health {
	gint current;
	gint maximum;
};

struct _Tween {
	gdouble min;
	gdouble max;
	gdouble speed;
	gboolean repeat;
	gboolean active;
};

struct _Entity {
	Id id;
	Name name;
	Active active;
	ActorType actor;
	ActorStyle style;
	Point2d position;
	SDL_Rect bounds;
	Vector2d scale;
	Sprite sprite;
	Sound* sound;
	Color* tint;
	Duration* expires;
	Health* health;
	Tween* tween;
	Vector2d* velocity;
};

struct _Metrics {
	gint bullet;
	gint enemy1;
	gint enemy2;
	gint enemy3;
	gint explosion;
	gint bang;
	gint particle;
	gint count;
};

struct _Game {
	GObject parent_instance;
	GamePrivate * priv;
	gchar* title;
	gint width;
	gint height;
	gint fps;
	gint mouseX;
	gint mouseY;
	gboolean mouseDown;
	gdouble delta;
	gdouble FireRate;
	gdouble timeToFire;
	gdouble enemyT1;
	gdouble enemyT2;
	gdouble enemyT3;
	GRand* rand;
	Entity* player;
	SDL_Window* window;
	SDL_Renderer* renderer;
	Entity* pool;
	gint pool_length1;
	guint8* keys;
	gint keys_length1;
	GeeArrayList* sprites;
	GeeArrayList* entity;
	GeeArrayList* unused;
	GeeArrayList* bullets;
	GeeArrayList* enemies1;
	GeeArrayList* enemies2;
	GeeArrayList* enemies3;
	GeeArrayList* explosions;
	GeeArrayList* bangs;
	GeeArrayList* particles;
	Metrics missing;
};

struct _GameClass {
	GObjectClass parent_class;
};



GType game_get_type (void) G_GNUC_CONST;
GType entity_get_type (void) G_GNUC_CONST;
GType id_get_type (void) G_GNUC_CONST;
Id* id_dup (const Id* self);
void id_free (Id* self);
GType name_get_type (void) G_GNUC_CONST;
Name* name_dup (const Name* self);
void name_free (Name* self);
void name_copy (const Name* self, Name* dest);
void name_destroy (Name* self);
GType active_get_type (void) G_GNUC_CONST;
Active* active_dup (const Active* self);
void active_free (Active* self);
GType actor_type_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
ActorType* actor_type_dup (const ActorType* self);
void actor_type_free (ActorType* self);
GType actor_style_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
ActorStyle* actor_style_dup (const ActorStyle* self);
void actor_style_free (ActorStyle* self);
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
GType sprite_get_type (void) G_GNUC_CONST;
Sprite* sprite_dup (const Sprite* self);
void sprite_free (Sprite* self);
GType sound_get_type (void) G_GNUC_CONST;
Sound* sound_dup (const Sound* self);
void sound_free (Sound* self);
GType color_get_type (void) G_GNUC_CONST;
Color* color_dup (const Color* self);
void color_free (Color* self);
GType duration_get_type (void) G_GNUC_CONST;
Duration* duration_dup (const Duration* self);
void duration_free (Duration* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
GType tween_get_type (void) G_GNUC_CONST;
Tween* tween_dup (const Tween* self);
void tween_free (Tween* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
void inputSystem (Game* game, Entity** entity);
GType metrics_get_type (void) G_GNUC_CONST;
Metrics* metrics_dup (const Metrics* self);
void metrics_free (Metrics* self);
gboolean game_getKey (Game* self, gint key);
void soundSystem (Game* game, Entity* entity);
void physicsSystem (Game* game, Entity** entity);
void expireSystem (Game* game, Entity** entity);
void game_removeSprite (Game* self, Entity* e);
void tweenSystem (Game* game, Entity** entity);
void removeSystem (Game* game, Entity** entity);
gdouble spawnEnemy (Game* game, gdouble delta, gdouble t, gint enemy);
void spawnSystem (Game* game, Entity** entity);
void factorySystem (Game* game, Entity** entity);
void initBullet (Game* game, Entity** entity, gint x, gint y);
void initEnemy1 (Game* game, Entity** entity, gint x, gint y);
void initEnemy2 (Game* game, Entity** entity, gint x, gint y);
void initEnemy3 (Game* game, Entity** entity, gint x, gint y);
void initExplosion (Game* game, Entity** entity, gint x, gint y);
void initBang (Game* game, Entity** entity, gint x, gint y);
void initParticle (Game* game, Entity** entity, gint x, gint y);
void handleCollision (Game* game, Entity** a, Entity** b);
void collisionSystem (Game* game, Entity** entity);


/**
 * inputSystem
 *
 * process user input
 *
 * @param game
 * @param entity
 */
void inputSystem (Game* game, Entity** entity) {
	gboolean _tmp0_ = FALSE;
	Entity* _tmp1_;
	Active _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (game != NULL);
	_tmp1_ = *entity;
	_tmp2_ = (*_tmp1_).active;
	_tmp3_ = _tmp2_.active;
	if (_tmp3_) {
		Entity* _tmp4_;
		ActorType _tmp5_;
		Actor _tmp6_;
		_tmp4_ = *entity;
		_tmp5_ = (*_tmp4_).actor;
		_tmp6_ = _tmp5_.isA;
		_tmp0_ = _tmp6_ == ACTOR_PLAYER;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		Game* _tmp7_;
		gint _tmp8_;
		Game* _tmp9_;
		gint _tmp10_;
		gboolean _tmp11_ = FALSE;
		Game* _tmp12_;
		gboolean _tmp13_;
		_tmp7_ = game;
		_tmp8_ = _tmp7_->mouseX;
		(*(*entity)).position.x = (gdouble) _tmp8_;
		_tmp9_ = game;
		_tmp10_ = _tmp9_->mouseY;
		(*(*entity)).position.y = (gdouble) _tmp10_;
		_tmp12_ = game;
		_tmp13_ = game_getKey (_tmp12_, 122);
		if (_tmp13_) {
			_tmp11_ = TRUE;
		} else {
			Game* _tmp14_;
			gboolean _tmp15_;
			_tmp14_ = game;
			_tmp15_ = _tmp14_->mouseDown;
			_tmp11_ = _tmp15_;
		}
		if (_tmp11_) {
			Game* _tmp16_;
			Game* _tmp17_;
			gdouble _tmp18_;
			Game* _tmp19_;
			gdouble _tmp20_;
			Game* _tmp21_;
			gdouble _tmp22_;
			_tmp16_ = game;
			_tmp17_ = game;
			_tmp18_ = _tmp17_->timeToFire;
			_tmp19_ = game;
			_tmp20_ = _tmp19_->delta;
			_tmp17_->timeToFire = _tmp18_ - _tmp20_;
			_tmp21_ = game;
			_tmp22_ = _tmp21_->timeToFire;
			if (_tmp22_ < 0.0) {
				Game* _tmp23_;
				GeeArrayList* _tmp24_;
				Entity* _tmp25_;
				Point2d _tmp26_;
				gdouble _tmp27_;
				Entity* _tmp28_;
				Point2d _tmp29_;
				gdouble _tmp30_;
				Point2d _tmp31_ = {0};
				Game* _tmp32_;
				GeeArrayList* _tmp33_;
				Entity* _tmp34_;
				Point2d _tmp35_;
				gdouble _tmp36_;
				Entity* _tmp37_;
				Point2d _tmp38_;
				gdouble _tmp39_;
				Point2d _tmp40_ = {0};
				Game* _tmp41_;
				Game* _tmp42_;
				gdouble _tmp43_;
				_tmp23_ = game;
				_tmp24_ = _tmp23_->bullets;
				_tmp25_ = *entity;
				_tmp26_ = (*_tmp25_).position;
				_tmp27_ = _tmp26_.x;
				_tmp28_ = *entity;
				_tmp29_ = (*_tmp28_).position;
				_tmp30_ = _tmp29_.y;
				_tmp31_.x = _tmp27_ - 27;
				_tmp31_.y = _tmp30_ + 2;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp24_, &_tmp31_);
				_tmp32_ = game;
				_tmp33_ = _tmp32_->bullets;
				_tmp34_ = *entity;
				_tmp35_ = (*_tmp34_).position;
				_tmp36_ = _tmp35_.x;
				_tmp37_ = *entity;
				_tmp38_ = (*_tmp37_).position;
				_tmp39_ = _tmp38_.y;
				_tmp40_.x = _tmp36_ + 27;
				_tmp40_.y = _tmp39_ + 2;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp33_, &_tmp40_);
				_tmp41_ = game;
				_tmp42_ = game;
				_tmp43_ = _tmp42_->FireRate;
				_tmp41_->timeToFire = _tmp43_;
			}
		}
	}
}


/**
 * soundSystem
 *
 * play sound effect
 *
 * @param game
 * @param entity
 */
void soundSystem (Game* game, Entity* entity) {
	gboolean _tmp0_ = FALSE;
	Entity _tmp1_;
	Active _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (game != NULL);
	g_return_if_fail (entity != NULL);
	_tmp1_ = *entity;
	_tmp2_ = _tmp1_.active;
	_tmp3_ = _tmp2_.active;
	if (_tmp3_) {
		Entity _tmp4_;
		Sound* _tmp5_;
		_tmp4_ = *entity;
		_tmp5_ = _tmp4_.sound;
		_tmp0_ = _tmp5_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		Entity _tmp6_;
		Sound* _tmp7_;
		Mix_Chunk* _tmp8_;
		_tmp6_ = *entity;
		_tmp7_ = _tmp6_.sound;
		_tmp8_ = (*_tmp7_).effect;
		Mix_PlayChannel (-1, _tmp8_, 0);
	}
}


/**
 * physicsSystem
 *
 * update movement
 *
 * @param game
 * @param entity
 */
void physicsSystem (Game* game, Entity** entity) {
	gboolean _tmp0_ = FALSE;
	Entity* _tmp1_;
	Active _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (game != NULL);
	_tmp1_ = *entity;
	_tmp2_ = (*_tmp1_).active;
	_tmp3_ = _tmp2_.active;
	if (_tmp3_) {
		Entity* _tmp4_;
		Vector2d* _tmp5_;
		_tmp4_ = *entity;
		_tmp5_ = (*_tmp4_).velocity;
		_tmp0_ = _tmp5_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gdouble _tmp6_;
		Entity* _tmp7_;
		Vector2d* _tmp8_;
		gdouble _tmp9_;
		Game* _tmp10_;
		gdouble _tmp11_;
		gdouble _tmp12_;
		Entity* _tmp13_;
		Vector2d* _tmp14_;
		gdouble _tmp15_;
		Game* _tmp16_;
		gdouble _tmp17_;
		_tmp6_ = (*(*entity)).position.x;
		_tmp7_ = *entity;
		_tmp8_ = (*_tmp7_).velocity;
		_tmp9_ = (*_tmp8_).x;
		_tmp10_ = game;
		_tmp11_ = _tmp10_->delta;
		(*(*entity)).position.x = _tmp6_ + (_tmp9_ * _tmp11_);
		_tmp12_ = (*(*entity)).position.y;
		_tmp13_ = *entity;
		_tmp14_ = (*_tmp13_).velocity;
		_tmp15_ = (*_tmp14_).y;
		_tmp16_ = game;
		_tmp17_ = _tmp16_->delta;
		(*(*entity)).position.y = _tmp12_ + (_tmp15_ * _tmp17_);
	}
}


/**
 * expireSystem
 *
 * deactivate entities on timeout
 *
 * @param game
 * @param entity
 */
void expireSystem (Game* game, Entity** entity) {
	gboolean _tmp0_ = FALSE;
	Entity* _tmp1_;
	Active _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (game != NULL);
	_tmp1_ = *entity;
	_tmp2_ = (*_tmp1_).active;
	_tmp3_ = _tmp2_.active;
	if (_tmp3_) {
		Entity* _tmp4_;
		Duration* _tmp5_;
		_tmp4_ = *entity;
		_tmp5_ = (*_tmp4_).expires;
		_tmp0_ = _tmp5_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gdouble exp = 0.0;
		Entity* _tmp6_;
		Duration* _tmp7_;
		gdouble _tmp8_;
		Game* _tmp9_;
		gdouble _tmp10_;
		Entity* _tmp11_;
		Duration* _tmp12_;
		gdouble _tmp13_;
		Entity* _tmp14_;
		Duration* _tmp15_;
		gdouble _tmp16_;
		_tmp6_ = *entity;
		_tmp7_ = (*_tmp6_).expires;
		_tmp8_ = (*_tmp7_).timer;
		_tmp9_ = game;
		_tmp10_ = _tmp9_->delta;
		exp = _tmp8_ - _tmp10_;
		_tmp11_ = *entity;
		_tmp12_ = (*_tmp11_).expires;
		_tmp13_ = exp;
		(*_tmp12_).timer = _tmp13_;
		_tmp14_ = *entity;
		_tmp15_ = (*_tmp14_).expires;
		_tmp16_ = (*_tmp15_).timer;
		if (_tmp16_ < ((gdouble) 0)) {
			Game* _tmp17_;
			Entity* _tmp18_;
			(*(*entity)).active.active = FALSE;
			_tmp17_ = game;
			_tmp18_ = *entity;
			game_removeSprite (_tmp17_, _tmp18_);
		}
	}
}


/**
 * tweenSystem
 *
 * do animations
 *
 * @param game
 * @param entity
 */
void tweenSystem (Game* game, Entity** entity) {
	gboolean _tmp0_ = FALSE;
	Entity* _tmp1_;
	Active _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (game != NULL);
	_tmp1_ = *entity;
	_tmp2_ = (*_tmp1_).active;
	_tmp3_ = _tmp2_.active;
	if (_tmp3_) {
		Entity* _tmp4_;
		Tween* _tmp5_;
		_tmp4_ = *entity;
		_tmp5_ = (*_tmp4_).tween;
		_tmp0_ = _tmp5_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gdouble x = 0.0;
		Entity* _tmp6_;
		Vector2d _tmp7_;
		gdouble _tmp8_;
		Entity* _tmp9_;
		Tween* _tmp10_;
		gdouble _tmp11_;
		Game* _tmp12_;
		gdouble _tmp13_;
		gdouble y = 0.0;
		Entity* _tmp14_;
		Vector2d _tmp15_;
		gdouble _tmp16_;
		Entity* _tmp17_;
		Tween* _tmp18_;
		gdouble _tmp19_;
		Game* _tmp20_;
		gdouble _tmp21_;
		gboolean active = FALSE;
		Entity* _tmp22_;
		Tween* _tmp23_;
		gboolean _tmp24_;
		gdouble _tmp25_;
		Entity* _tmp26_;
		Tween* _tmp27_;
		gdouble _tmp28_;
		gdouble _tmp45_;
		gdouble _tmp46_;
		Entity* _tmp47_;
		Tween* _tmp48_;
		gboolean _tmp49_;
		_tmp6_ = *entity;
		_tmp7_ = (*_tmp6_).scale;
		_tmp8_ = _tmp7_.x;
		_tmp9_ = *entity;
		_tmp10_ = (*_tmp9_).tween;
		_tmp11_ = (*_tmp10_).speed;
		_tmp12_ = game;
		_tmp13_ = _tmp12_->delta;
		x = _tmp8_ + (_tmp11_ * _tmp13_);
		_tmp14_ = *entity;
		_tmp15_ = (*_tmp14_).scale;
		_tmp16_ = _tmp15_.y;
		_tmp17_ = *entity;
		_tmp18_ = (*_tmp17_).tween;
		_tmp19_ = (*_tmp18_).speed;
		_tmp20_ = game;
		_tmp21_ = _tmp20_->delta;
		y = _tmp16_ + (_tmp19_ * _tmp21_);
		_tmp22_ = *entity;
		_tmp23_ = (*_tmp22_).tween;
		_tmp24_ = (*_tmp23_).active;
		active = _tmp24_;
		_tmp25_ = x;
		_tmp26_ = *entity;
		_tmp27_ = (*_tmp26_).tween;
		_tmp28_ = (*_tmp27_).max;
		if (_tmp25_ > _tmp28_) {
			Entity* _tmp29_;
			Tween* _tmp30_;
			gdouble _tmp31_;
			Entity* _tmp32_;
			Tween* _tmp33_;
			gdouble _tmp34_;
			_tmp29_ = *entity;
			_tmp30_ = (*_tmp29_).tween;
			_tmp31_ = (*_tmp30_).max;
			x = _tmp31_;
			_tmp32_ = *entity;
			_tmp33_ = (*_tmp32_).tween;
			_tmp34_ = (*_tmp33_).max;
			y = _tmp34_;
			active = FALSE;
		} else {
			gdouble _tmp35_;
			Entity* _tmp36_;
			Tween* _tmp37_;
			gdouble _tmp38_;
			_tmp35_ = x;
			_tmp36_ = *entity;
			_tmp37_ = (*_tmp36_).tween;
			_tmp38_ = (*_tmp37_).min;
			if (_tmp35_ < _tmp38_) {
				Entity* _tmp39_;
				Tween* _tmp40_;
				gdouble _tmp41_;
				Entity* _tmp42_;
				Tween* _tmp43_;
				gdouble _tmp44_;
				_tmp39_ = *entity;
				_tmp40_ = (*_tmp39_).tween;
				_tmp41_ = (*_tmp40_).min;
				x = _tmp41_;
				_tmp42_ = *entity;
				_tmp43_ = (*_tmp42_).tween;
				_tmp44_ = (*_tmp43_).min;
				y = _tmp44_;
				active = FALSE;
			}
		}
		_tmp45_ = x;
		(*(*entity)).scale.x = _tmp45_;
		_tmp46_ = y;
		(*(*entity)).scale.y = _tmp46_;
		_tmp47_ = *entity;
		_tmp48_ = (*_tmp47_).tween;
		_tmp49_ = active;
		(*_tmp48_).active = _tmp49_;
	}
}


/**
 * removeSystem
 *
 * deactivate entities when they leave the screen
 *
 * @param game
 * @param entity
 */
void removeSystem (Game* game, Entity** entity) {
	Entity* _tmp0_;
	Active _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (game != NULL);
	_tmp0_ = *entity;
	_tmp1_ = (*_tmp0_).active;
	_tmp2_ = _tmp1_.active;
	if (_tmp2_) {
		Entity* _tmp3_;
		ActorStyle _tmp4_;
		Category _tmp5_;
		_tmp3_ = *entity;
		_tmp4_ = (*_tmp3_).style;
		_tmp5_ = _tmp4_.isA;
		switch (_tmp5_) {
			case CATEGORY_ENEMY:
			{
				{
					Entity* _tmp6_;
					Point2d _tmp7_;
					gdouble _tmp8_;
					Game* _tmp9_;
					gint _tmp10_;
					_tmp6_ = *entity;
					_tmp7_ = (*_tmp6_).position;
					_tmp8_ = _tmp7_.y;
					_tmp9_ = game;
					_tmp10_ = _tmp9_->height;
					if (_tmp8_ > ((gdouble) _tmp10_)) {
						Game* _tmp11_;
						Entity* _tmp12_;
						(*(*entity)).active.active = FALSE;
						_tmp11_ = game;
						_tmp12_ = *entity;
						game_removeSprite (_tmp11_, _tmp12_);
					}
				}
				break;
			}
			case CATEGORY_BULLET:
			{
				{
					Entity* _tmp13_;
					Point2d _tmp14_;
					gdouble _tmp15_;
					_tmp13_ = *entity;
					_tmp14_ = (*_tmp13_).position;
					_tmp15_ = _tmp14_.y;
					if (_tmp15_ < ((gdouble) 0)) {
						Game* _tmp16_;
						Entity* _tmp17_;
						(*(*entity)).active.active = FALSE;
						_tmp16_ = game;
						_tmp17_ = *entity;
						game_removeSprite (_tmp16_, _tmp17_);
					}
				}
				break;
			}
			default:
			break;
		}
	}
}


/**
 * spawnSystem
 *
 * generate enemies
 *
 * @param game
 * @param entity
 */
gdouble spawnEnemy (Game* game, gdouble delta, gdouble t, gint enemy) {
	gdouble result = 0.0;
	gdouble d1 = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	g_return_val_if_fail (game != NULL, 0.0);
	_tmp0_ = t;
	_tmp1_ = delta;
	d1 = _tmp0_ - _tmp1_;
	_tmp2_ = d1;
	if (_tmp2_ < 0.0) {
		gint _tmp3_;
		_tmp3_ = enemy;
		switch (_tmp3_) {
			case 1:
			{
				{
					Game* _tmp4_;
					GeeArrayList* _tmp5_;
					Game* _tmp6_;
					GRand* _tmp7_;
					Game* _tmp8_;
					gint _tmp9_;
					gint32 _tmp10_;
					Point2d _tmp11_ = {0};
					_tmp4_ = game;
					_tmp5_ = _tmp4_->enemies1;
					_tmp6_ = game;
					_tmp7_ = _tmp6_->rand;
					_tmp8_ = game;
					_tmp9_ = _tmp8_->width;
					_tmp10_ = g_rand_int_range (_tmp7_, (gint32) 35, (gint32) (_tmp9_ - 35));
					_tmp11_.x = (gdouble) _tmp10_;
					_tmp11_.y = (gdouble) 35;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, &_tmp11_);
					result = 1.0;
					return result;
				}
				break;
			}
			case 2:
			{
				{
					Game* _tmp12_;
					GeeArrayList* _tmp13_;
					Game* _tmp14_;
					GRand* _tmp15_;
					Game* _tmp16_;
					gint _tmp17_;
					gint32 _tmp18_;
					Point2d _tmp19_ = {0};
					_tmp12_ = game;
					_tmp13_ = _tmp12_->enemies2;
					_tmp14_ = game;
					_tmp15_ = _tmp14_->rand;
					_tmp16_ = game;
					_tmp17_ = _tmp16_->width;
					_tmp18_ = g_rand_int_range (_tmp15_, (gint32) 85, (gint32) (_tmp17_ - 85));
					_tmp19_.x = (gdouble) _tmp18_;
					_tmp19_.y = (gdouble) 85;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp13_, &_tmp19_);
					result = 4.0;
					return result;
				}
				break;
			}
			case 3:
			{
				{
					Game* _tmp20_;
					GeeArrayList* _tmp21_;
					Game* _tmp22_;
					GRand* _tmp23_;
					Game* _tmp24_;
					gint _tmp25_;
					gint32 _tmp26_;
					Point2d _tmp27_ = {0};
					_tmp20_ = game;
					_tmp21_ = _tmp20_->enemies3;
					_tmp22_ = game;
					_tmp23_ = _tmp22_->rand;
					_tmp24_ = game;
					_tmp25_ = _tmp24_->width;
					_tmp26_ = g_rand_int_range (_tmp23_, (gint32) 160, (gint32) (_tmp25_ - 160));
					_tmp27_.x = (gdouble) _tmp26_;
					_tmp27_.y = (gdouble) 160;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp21_, &_tmp27_);
					result = 6.0;
					return result;
				}
				break;
			}
			default:
			{
				{
					result = 0.0;
					return result;
				}
				break;
			}
		}
	} else {
		result = d1;
		return result;
	}
}


void spawnSystem (Game* game, Entity** entity) {
	Game* _tmp0_;
	Game* _tmp1_;
	Game* _tmp2_;
	gdouble _tmp3_;
	Game* _tmp4_;
	gdouble _tmp5_;
	gdouble _tmp6_;
	Game* _tmp7_;
	Game* _tmp8_;
	Game* _tmp9_;
	gdouble _tmp10_;
	Game* _tmp11_;
	gdouble _tmp12_;
	gdouble _tmp13_;
	Game* _tmp14_;
	Game* _tmp15_;
	Game* _tmp16_;
	gdouble _tmp17_;
	Game* _tmp18_;
	gdouble _tmp19_;
	gdouble _tmp20_;
	g_return_if_fail (game != NULL);
	_tmp0_ = game;
	_tmp1_ = game;
	_tmp2_ = game;
	_tmp3_ = _tmp2_->delta;
	_tmp4_ = game;
	_tmp5_ = _tmp4_->enemyT1;
	_tmp6_ = spawnEnemy (_tmp1_, _tmp3_, _tmp5_, 1);
	_tmp0_->enemyT1 = _tmp6_;
	_tmp7_ = game;
	_tmp8_ = game;
	_tmp9_ = game;
	_tmp10_ = _tmp9_->delta;
	_tmp11_ = game;
	_tmp12_ = _tmp11_->enemyT2;
	_tmp13_ = spawnEnemy (_tmp8_, _tmp10_, _tmp12_, 2);
	_tmp7_->enemyT2 = _tmp13_;
	_tmp14_ = game;
	_tmp15_ = game;
	_tmp16_ = game;
	_tmp17_ = _tmp16_->delta;
	_tmp18_ = game;
	_tmp19_ = _tmp18_->enemyT3;
	_tmp20_ = spawnEnemy (_tmp15_, _tmp17_, _tmp19_, 3);
	_tmp14_->enemyT3 = _tmp20_;
}


/**
 * factorySystem
 *
 * create entities on request
 *
 * @param game
 * @param entity
 */
void factorySystem (Game* game, Entity** entity) {
	Entity* _tmp0_;
	Active _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (game != NULL);
	_tmp0_ = *entity;
	_tmp1_ = (*_tmp0_).active;
	_tmp2_ = _tmp1_.active;
	if (!_tmp2_) {
		Entity* _tmp3_;
		ActorType _tmp4_;
		Actor _tmp5_;
		_tmp3_ = *entity;
		_tmp4_ = (*_tmp3_).actor;
		_tmp5_ = _tmp4_.isA;
		switch (_tmp5_) {
			case ACTOR_BULLET:
			{
				{
					Game* _tmp6_;
					GeeArrayList* _tmp7_;
					gboolean _tmp8_;
					gboolean _tmp9_;
					Game* _tmp10_;
					Game* _tmp11_;
					GeeArrayList* _tmp12_;
					gpointer _tmp13_;
					Point2d* _tmp14_;
					gdouble _tmp15_;
					Game* _tmp16_;
					GeeArrayList* _tmp17_;
					gpointer _tmp18_;
					Point2d* _tmp19_;
					gdouble _tmp20_;
					Game* _tmp21_;
					GeeArrayList* _tmp22_;
					gpointer _tmp23_;
					Point2d* _tmp24_;
					_tmp6_ = game;
					_tmp7_ = _tmp6_->bullets;
					_tmp8_ = gee_collection_get_is_empty ((GeeCollection*) _tmp7_);
					_tmp9_ = _tmp8_;
					if (_tmp9_) {
						break;
					}
					_tmp10_ = game;
					_tmp11_ = game;
					_tmp12_ = _tmp11_->bullets;
					_tmp13_ = gee_list_first ((GeeList*) _tmp12_);
					_tmp14_ = (Point2d*) _tmp13_;
					_tmp15_ = (*_tmp14_).x;
					_tmp16_ = game;
					_tmp17_ = _tmp16_->bullets;
					_tmp18_ = gee_list_first ((GeeList*) _tmp17_);
					_tmp19_ = (Point2d*) _tmp18_;
					_tmp20_ = (*_tmp19_).y;
					initBullet (_tmp10_, entity, (gint) _tmp15_, (gint) _tmp20_);
					_point2d_free0 (_tmp19_);
					_point2d_free0 (_tmp14_);
					_tmp21_ = game;
					_tmp22_ = _tmp21_->bullets;
					_tmp23_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp22_, 0);
					_tmp24_ = (Point2d*) _tmp23_;
					_point2d_free0 (_tmp24_);
				}
				break;
			}
			case ACTOR_ENEMY1:
			{
				{
					Game* _tmp25_;
					GeeArrayList* _tmp26_;
					gboolean _tmp27_;
					gboolean _tmp28_;
					Game* _tmp29_;
					Game* _tmp30_;
					GeeArrayList* _tmp31_;
					gpointer _tmp32_;
					Point2d* _tmp33_;
					gdouble _tmp34_;
					Game* _tmp35_;
					GeeArrayList* _tmp36_;
					gpointer _tmp37_;
					Point2d* _tmp38_;
					gdouble _tmp39_;
					Game* _tmp40_;
					GeeArrayList* _tmp41_;
					gpointer _tmp42_;
					Point2d* _tmp43_;
					_tmp25_ = game;
					_tmp26_ = _tmp25_->enemies1;
					_tmp27_ = gee_collection_get_is_empty ((GeeCollection*) _tmp26_);
					_tmp28_ = _tmp27_;
					if (_tmp28_) {
						break;
					}
					_tmp29_ = game;
					_tmp30_ = game;
					_tmp31_ = _tmp30_->enemies1;
					_tmp32_ = gee_list_first ((GeeList*) _tmp31_);
					_tmp33_ = (Point2d*) _tmp32_;
					_tmp34_ = (*_tmp33_).x;
					_tmp35_ = game;
					_tmp36_ = _tmp35_->enemies1;
					_tmp37_ = gee_list_first ((GeeList*) _tmp36_);
					_tmp38_ = (Point2d*) _tmp37_;
					_tmp39_ = (*_tmp38_).y;
					initEnemy1 (_tmp29_, entity, (gint) _tmp34_, (gint) _tmp39_);
					_point2d_free0 (_tmp38_);
					_point2d_free0 (_tmp33_);
					_tmp40_ = game;
					_tmp41_ = _tmp40_->enemies1;
					_tmp42_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp41_, 0);
					_tmp43_ = (Point2d*) _tmp42_;
					_point2d_free0 (_tmp43_);
				}
				break;
			}
			case ACTOR_ENEMY2:
			{
				{
					Game* _tmp44_;
					GeeArrayList* _tmp45_;
					gboolean _tmp46_;
					gboolean _tmp47_;
					Game* _tmp48_;
					Game* _tmp49_;
					GeeArrayList* _tmp50_;
					gpointer _tmp51_;
					Point2d* _tmp52_;
					gdouble _tmp53_;
					Game* _tmp54_;
					GeeArrayList* _tmp55_;
					gpointer _tmp56_;
					Point2d* _tmp57_;
					gdouble _tmp58_;
					Game* _tmp59_;
					GeeArrayList* _tmp60_;
					gpointer _tmp61_;
					Point2d* _tmp62_;
					_tmp44_ = game;
					_tmp45_ = _tmp44_->enemies2;
					_tmp46_ = gee_collection_get_is_empty ((GeeCollection*) _tmp45_);
					_tmp47_ = _tmp46_;
					if (_tmp47_) {
						break;
					}
					_tmp48_ = game;
					_tmp49_ = game;
					_tmp50_ = _tmp49_->enemies2;
					_tmp51_ = gee_list_first ((GeeList*) _tmp50_);
					_tmp52_ = (Point2d*) _tmp51_;
					_tmp53_ = (*_tmp52_).x;
					_tmp54_ = game;
					_tmp55_ = _tmp54_->enemies2;
					_tmp56_ = gee_list_first ((GeeList*) _tmp55_);
					_tmp57_ = (Point2d*) _tmp56_;
					_tmp58_ = (*_tmp57_).y;
					initEnemy2 (_tmp48_, entity, (gint) _tmp53_, (gint) _tmp58_);
					_point2d_free0 (_tmp57_);
					_point2d_free0 (_tmp52_);
					_tmp59_ = game;
					_tmp60_ = _tmp59_->enemies2;
					_tmp61_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp60_, 0);
					_tmp62_ = (Point2d*) _tmp61_;
					_point2d_free0 (_tmp62_);
				}
				break;
			}
			case ACTOR_ENEMY3:
			{
				{
					Game* _tmp63_;
					GeeArrayList* _tmp64_;
					gboolean _tmp65_;
					gboolean _tmp66_;
					Game* _tmp67_;
					Game* _tmp68_;
					GeeArrayList* _tmp69_;
					gpointer _tmp70_;
					Point2d* _tmp71_;
					gdouble _tmp72_;
					Game* _tmp73_;
					GeeArrayList* _tmp74_;
					gpointer _tmp75_;
					Point2d* _tmp76_;
					gdouble _tmp77_;
					Game* _tmp78_;
					GeeArrayList* _tmp79_;
					gpointer _tmp80_;
					Point2d* _tmp81_;
					_tmp63_ = game;
					_tmp64_ = _tmp63_->enemies3;
					_tmp65_ = gee_collection_get_is_empty ((GeeCollection*) _tmp64_);
					_tmp66_ = _tmp65_;
					if (_tmp66_) {
						break;
					}
					_tmp67_ = game;
					_tmp68_ = game;
					_tmp69_ = _tmp68_->enemies3;
					_tmp70_ = gee_list_first ((GeeList*) _tmp69_);
					_tmp71_ = (Point2d*) _tmp70_;
					_tmp72_ = (*_tmp71_).x;
					_tmp73_ = game;
					_tmp74_ = _tmp73_->enemies3;
					_tmp75_ = gee_list_first ((GeeList*) _tmp74_);
					_tmp76_ = (Point2d*) _tmp75_;
					_tmp77_ = (*_tmp76_).y;
					initEnemy3 (_tmp67_, entity, (gint) _tmp72_, (gint) _tmp77_);
					_point2d_free0 (_tmp76_);
					_point2d_free0 (_tmp71_);
					_tmp78_ = game;
					_tmp79_ = _tmp78_->enemies3;
					_tmp80_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp79_, 0);
					_tmp81_ = (Point2d*) _tmp80_;
					_point2d_free0 (_tmp81_);
				}
				break;
			}
			case ACTOR_EXPLOSION:
			{
				{
					Game* _tmp82_;
					GeeArrayList* _tmp83_;
					gboolean _tmp84_;
					gboolean _tmp85_;
					Game* _tmp86_;
					Game* _tmp87_;
					GeeArrayList* _tmp88_;
					gpointer _tmp89_;
					Point2d* _tmp90_;
					gdouble _tmp91_;
					Game* _tmp92_;
					GeeArrayList* _tmp93_;
					gpointer _tmp94_;
					Point2d* _tmp95_;
					gdouble _tmp96_;
					Game* _tmp97_;
					GeeArrayList* _tmp98_;
					gpointer _tmp99_;
					Point2d* _tmp100_;
					_tmp82_ = game;
					_tmp83_ = _tmp82_->explosions;
					_tmp84_ = gee_collection_get_is_empty ((GeeCollection*) _tmp83_);
					_tmp85_ = _tmp84_;
					if (_tmp85_) {
						break;
					}
					_tmp86_ = game;
					_tmp87_ = game;
					_tmp88_ = _tmp87_->explosions;
					_tmp89_ = gee_list_first ((GeeList*) _tmp88_);
					_tmp90_ = (Point2d*) _tmp89_;
					_tmp91_ = (*_tmp90_).x;
					_tmp92_ = game;
					_tmp93_ = _tmp92_->explosions;
					_tmp94_ = gee_list_first ((GeeList*) _tmp93_);
					_tmp95_ = (Point2d*) _tmp94_;
					_tmp96_ = (*_tmp95_).y;
					initExplosion (_tmp86_, entity, (gint) _tmp91_, (gint) _tmp96_);
					_point2d_free0 (_tmp95_);
					_point2d_free0 (_tmp90_);
					_tmp97_ = game;
					_tmp98_ = _tmp97_->explosions;
					_tmp99_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp98_, 0);
					_tmp100_ = (Point2d*) _tmp99_;
					_point2d_free0 (_tmp100_);
				}
				break;
			}
			case ACTOR_BANG:
			{
				{
					Game* _tmp101_;
					GeeArrayList* _tmp102_;
					gboolean _tmp103_;
					gboolean _tmp104_;
					Game* _tmp105_;
					Game* _tmp106_;
					GeeArrayList* _tmp107_;
					gpointer _tmp108_;
					Point2d* _tmp109_;
					gdouble _tmp110_;
					Game* _tmp111_;
					GeeArrayList* _tmp112_;
					gpointer _tmp113_;
					Point2d* _tmp114_;
					gdouble _tmp115_;
					Game* _tmp116_;
					GeeArrayList* _tmp117_;
					gpointer _tmp118_;
					Point2d* _tmp119_;
					_tmp101_ = game;
					_tmp102_ = _tmp101_->bangs;
					_tmp103_ = gee_collection_get_is_empty ((GeeCollection*) _tmp102_);
					_tmp104_ = _tmp103_;
					if (_tmp104_) {
						break;
					}
					_tmp105_ = game;
					_tmp106_ = game;
					_tmp107_ = _tmp106_->bangs;
					_tmp108_ = gee_list_first ((GeeList*) _tmp107_);
					_tmp109_ = (Point2d*) _tmp108_;
					_tmp110_ = (*_tmp109_).x;
					_tmp111_ = game;
					_tmp112_ = _tmp111_->bangs;
					_tmp113_ = gee_list_first ((GeeList*) _tmp112_);
					_tmp114_ = (Point2d*) _tmp113_;
					_tmp115_ = (*_tmp114_).y;
					initBang (_tmp105_, entity, (gint) _tmp110_, (gint) _tmp115_);
					_point2d_free0 (_tmp114_);
					_point2d_free0 (_tmp109_);
					_tmp116_ = game;
					_tmp117_ = _tmp116_->bangs;
					_tmp118_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp117_, 0);
					_tmp119_ = (Point2d*) _tmp118_;
					_point2d_free0 (_tmp119_);
				}
				break;
			}
			case ACTOR_PARTICLE:
			{
				{
					Game* _tmp120_;
					GeeArrayList* _tmp121_;
					gboolean _tmp122_;
					gboolean _tmp123_;
					Game* _tmp124_;
					Game* _tmp125_;
					GeeArrayList* _tmp126_;
					gpointer _tmp127_;
					Point2d* _tmp128_;
					gdouble _tmp129_;
					Game* _tmp130_;
					GeeArrayList* _tmp131_;
					gpointer _tmp132_;
					Point2d* _tmp133_;
					gdouble _tmp134_;
					Game* _tmp135_;
					GeeArrayList* _tmp136_;
					gpointer _tmp137_;
					Point2d* _tmp138_;
					_tmp120_ = game;
					_tmp121_ = _tmp120_->particles;
					_tmp122_ = gee_collection_get_is_empty ((GeeCollection*) _tmp121_);
					_tmp123_ = _tmp122_;
					if (_tmp123_) {
						break;
					}
					_tmp124_ = game;
					_tmp125_ = game;
					_tmp126_ = _tmp125_->particles;
					_tmp127_ = gee_list_first ((GeeList*) _tmp126_);
					_tmp128_ = (Point2d*) _tmp127_;
					_tmp129_ = (*_tmp128_).x;
					_tmp130_ = game;
					_tmp131_ = _tmp130_->particles;
					_tmp132_ = gee_list_first ((GeeList*) _tmp131_);
					_tmp133_ = (Point2d*) _tmp132_;
					_tmp134_ = (*_tmp133_).y;
					initParticle (_tmp124_, entity, (gint) _tmp129_, (gint) _tmp134_);
					_point2d_free0 (_tmp133_);
					_point2d_free0 (_tmp128_);
					_tmp135_ = game;
					_tmp136_ = _tmp135_->particles;
					_tmp137_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp136_, 0);
					_tmp138_ = (Point2d*) _tmp137_;
					_point2d_free0 (_tmp138_);
				}
				break;
			}
			default:
			break;
		}
	}
}


static gpointer _health_dup0 (gpointer self) {
	return self ? health_dup (self) : NULL;
}


void handleCollision (Game* game, Entity** a, Entity** b) {
	Game* _tmp0_;
	GeeArrayList* _tmp1_;
	Entity* _tmp2_;
	SDL_Rect _tmp3_;
	gint _tmp4_;
	Entity* _tmp5_;
	SDL_Rect _tmp6_;
	gint _tmp7_;
	Point2d _tmp8_ = {0};
	Game* _tmp9_;
	Entity* _tmp10_;
	Entity* _tmp22_;
	Health* _tmp23_;
	g_return_if_fail (game != NULL);
	_tmp0_ = game;
	_tmp1_ = _tmp0_->bangs;
	_tmp2_ = *b;
	_tmp3_ = (*_tmp2_).bounds;
	_tmp4_ = _tmp3_.x;
	_tmp5_ = *b;
	_tmp6_ = (*_tmp5_).bounds;
	_tmp7_ = _tmp6_.y;
	_tmp8_.x = (gdouble) _tmp4_;
	_tmp8_.y = (gdouble) _tmp7_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp1_, &_tmp8_);
	(*(*b)).active.active = FALSE;
	_tmp9_ = game;
	_tmp10_ = *b;
	game_removeSprite (_tmp9_, _tmp10_);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp11_ = FALSE;
			_tmp11_ = TRUE;
			while (TRUE) {
				Game* _tmp13_;
				GeeArrayList* _tmp14_;
				Entity* _tmp15_;
				SDL_Rect _tmp16_;
				gint _tmp17_;
				Entity* _tmp18_;
				SDL_Rect _tmp19_;
				gint _tmp20_;
				Point2d _tmp21_ = {0};
				if (!_tmp11_) {
					gint _tmp12_;
					_tmp12_ = i;
					i = _tmp12_ + 1;
				}
				_tmp11_ = FALSE;
				if (!(i <= 3)) {
					break;
				}
				_tmp13_ = game;
				_tmp14_ = _tmp13_->particles;
				_tmp15_ = *b;
				_tmp16_ = (*_tmp15_).bounds;
				_tmp17_ = _tmp16_.x;
				_tmp18_ = *b;
				_tmp19_ = (*_tmp18_).bounds;
				_tmp20_ = _tmp19_.y;
				_tmp21_.x = (gdouble) _tmp17_;
				_tmp21_.y = (gdouble) _tmp20_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp14_, &_tmp21_);
			}
		}
	}
	_tmp22_ = *a;
	_tmp23_ = (*_tmp22_).health;
	if (_tmp23_ != NULL) {
		gint h = 0;
		Entity* _tmp24_;
		Health* _tmp25_;
		gint _tmp26_;
		gint _tmp27_;
		_tmp24_ = *a;
		_tmp25_ = (*_tmp24_).health;
		_tmp26_ = (*_tmp25_).current;
		h = _tmp26_ - 2;
		_tmp27_ = h;
		if (_tmp27_ < 0) {
			Game* _tmp28_;
			GeeArrayList* _tmp29_;
			Entity* _tmp30_;
			Point2d _tmp31_;
			gdouble _tmp32_;
			Entity* _tmp33_;
			Point2d _tmp34_;
			gdouble _tmp35_;
			Point2d _tmp36_ = {0};
			Game* _tmp37_;
			Entity* _tmp38_;
			_tmp28_ = game;
			_tmp29_ = _tmp28_->explosions;
			_tmp30_ = *a;
			_tmp31_ = (*_tmp30_).position;
			_tmp32_ = _tmp31_.x;
			_tmp33_ = *a;
			_tmp34_ = (*_tmp33_).position;
			_tmp35_ = _tmp34_.y;
			_tmp36_.x = _tmp32_;
			_tmp36_.y = _tmp35_;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp29_, &_tmp36_);
			(*(*a)).active.active = FALSE;
			_tmp37_ = game;
			_tmp38_ = *a;
			game_removeSprite (_tmp37_, _tmp38_);
		} else {
			gint _tmp39_;
			Entity* _tmp40_;
			Health* _tmp41_;
			gint _tmp42_;
			Health _tmp43_ = {0};
			Health* _tmp44_;
			_tmp39_ = h;
			_tmp40_ = *a;
			_tmp41_ = (*_tmp40_).health;
			_tmp42_ = (*_tmp41_).maximum;
			_tmp43_.current = _tmp39_;
			_tmp43_.maximum = _tmp42_;
			_tmp44_ = _health_dup0 (&_tmp43_);
			_health_free0 ((*(*a)).health);
			(*(*a)).health = _tmp44_;
		}
	}
}


/**
 * collisionSystem
 *
 * check for collisions
 *
 * @param game
 * @param entity
 */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void collisionSystem (Game* game, Entity** entity) {
	gboolean _tmp0_ = FALSE;
	Entity* _tmp1_;
	Active _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (game != NULL);
	_tmp1_ = *entity;
	_tmp2_ = (*_tmp1_).active;
	_tmp3_ = _tmp2_.active;
	if (_tmp3_) {
		Entity* _tmp4_;
		ActorStyle _tmp5_;
		Category _tmp6_;
		_tmp4_ = *entity;
		_tmp5_ = (*_tmp4_).style;
		_tmp6_ = _tmp5_.isA;
		_tmp0_ = _tmp6_ == CATEGORY_ENEMY;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		{
			GeeArrayList* _bullet_list = NULL;
			Game* _tmp7_;
			GeeArrayList* _tmp8_;
			GeeArrayList* _tmp9_;
			gint _bullet_size = 0;
			GeeArrayList* _tmp10_;
			gint _tmp11_;
			gint _tmp12_;
			gint _bullet_index = 0;
			_tmp7_ = game;
			_tmp8_ = _tmp7_->entity;
			_tmp9_ = _g_object_ref0 (_tmp8_);
			_bullet_list = _tmp9_;
			_tmp10_ = _bullet_list;
			_tmp11_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp10_);
			_tmp12_ = _tmp11_;
			_bullet_size = _tmp12_;
			_bullet_index = -1;
			while (TRUE) {
				gint _tmp13_;
				gint _tmp14_;
				gint _tmp15_;
				Entity* bullet = NULL;
				GeeArrayList* _tmp16_;
				gint _tmp17_;
				gpointer _tmp18_;
				gboolean _tmp19_ = FALSE;
				Entity* _tmp20_;
				Active _tmp21_;
				gboolean _tmp22_;
				_tmp13_ = _bullet_index;
				_bullet_index = _tmp13_ + 1;
				_tmp14_ = _bullet_index;
				_tmp15_ = _bullet_size;
				if (!(_tmp14_ < _tmp15_)) {
					break;
				}
				_tmp16_ = _bullet_list;
				_tmp17_ = _bullet_index;
				_tmp18_ = gee_abstract_list_get ((GeeAbstractList*) _tmp16_, _tmp17_);
				bullet = _tmp18_;
				_tmp20_ = bullet;
				_tmp21_ = (*_tmp20_).active;
				_tmp22_ = _tmp21_.active;
				if (_tmp22_) {
					Entity* _tmp23_;
					ActorStyle _tmp24_;
					Category _tmp25_;
					_tmp23_ = bullet;
					_tmp24_ = (*_tmp23_).style;
					_tmp25_ = _tmp24_.isA;
					_tmp19_ = _tmp25_ == CATEGORY_BULLET;
				} else {
					_tmp19_ = FALSE;
				}
				if (_tmp19_) {
					Entity* _tmp26_;
					SDL_Rect _tmp27_;
					gboolean _tmp28_;
					_tmp26_ = bullet;
					_tmp27_ = (*_tmp26_).bounds;
					_tmp28_ = SDL_HasIntersection (&(*(*entity)).bounds, &_tmp27_);
					if (_tmp28_) {
						gboolean _tmp29_ = FALSE;
						Entity* _tmp30_;
						Active _tmp31_;
						gboolean _tmp32_;
						_tmp30_ = *entity;
						_tmp31_ = (*_tmp30_).active;
						_tmp32_ = _tmp31_.active;
						if (_tmp32_) {
							Entity* _tmp33_;
							Active _tmp34_;
							gboolean _tmp35_;
							_tmp33_ = bullet;
							_tmp34_ = (*_tmp33_).active;
							_tmp35_ = _tmp34_.active;
							_tmp29_ = _tmp35_;
						} else {
							_tmp29_ = FALSE;
						}
						if (_tmp29_) {
							Game* _tmp36_;
							_tmp36_ = game;
							handleCollision (_tmp36_, entity, &bullet);
						}
						_g_object_unref0 (_bullet_list);
						return;
					}
				}
			}
			_g_object_unref0 (_bullet_list);
		}
	}
}



