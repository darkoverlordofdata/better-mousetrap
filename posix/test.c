/* test.c generated by valac 0.34.7, the Vala compiler
 * generated from test.gs, do not modify */

/* Genie for posixvala test */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_STRUCT_NAME (struct_name_get_type ())
typedef struct _StructName StructName;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_MY_ENUM (my_enum_get_type ())
typedef struct _Frodo Frodo;
#define _frodo_free0(var) ((var == NULL) ? NULL : (var = (frodo_free (var), NULL)))

struct _StructName {
	gchar* a;
	gint i;
};

typedef enum  {
	MY_ENUM_FirstValue = 1,
	MY_ENUM_ThirdValue = 3
} MyEnum;

struct _Frodo {
	gchar* name;
};

typedef gboolean (*DelegateType) (gint a, void* user_data);


GType struct_name_get_type (void) G_GNUC_CONST;
StructName* struct_name_dup (const StructName* self);
void struct_name_free (StructName* self);
void struct_name_copy (const StructName* self, StructName* dest);
void struct_name_destroy (StructName* self);
GType my_enum_get_type (void) G_GNUC_CONST;
void frodo_free (Frodo* self);
static void frodo_instance_init (Frodo * self);
Frodo* frodo_new (gint a);
gboolean f1 (gint a);
void f2 (DelegateType d, void* d_target, gint a);
gchar* fn_no_null (const gchar* param);
void _vala_main (gchar** args, int args_length1);
static gboolean _f1_delegate_type (gint a, gpointer self);


void struct_name_copy (const StructName* self, StructName* dest) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	_tmp0_ = (*self).a;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).a);
	(*dest).a = _tmp1_;
	_tmp2_ = (*self).i;
	(*dest).i = _tmp2_;
}


void struct_name_destroy (StructName* self) {
	_g_free0 ((*self).a);
}


StructName* struct_name_dup (const StructName* self) {
	StructName* dup;
	dup = g_new0 (StructName, 1);
	struct_name_copy (self, dup);
	return dup;
}


void struct_name_free (StructName* self) {
	struct_name_destroy (self);
	g_free (self);
}


GType struct_name_get_type (void) {
	static volatile gsize struct_name_type_id__volatile = 0;
	if (g_once_init_enter (&struct_name_type_id__volatile)) {
		GType struct_name_type_id;
		struct_name_type_id = g_boxed_type_register_static ("StructName", (GBoxedCopyFunc) struct_name_dup, (GBoxedFreeFunc) struct_name_free);
		g_once_init_leave (&struct_name_type_id__volatile, struct_name_type_id);
	}
	return struct_name_type_id__volatile;
}


GType my_enum_get_type (void) {
	static volatile gsize my_enum_type_id__volatile = 0;
	if (g_once_init_enter (&my_enum_type_id__volatile)) {
		static const GEnumValue values[] = {{MY_ENUM_FirstValue, "MY_ENUM_FirstValue", "firstvalue"}, {MY_ENUM_ThirdValue, "MY_ENUM_ThirdValue", "thirdvalue"}, {0, NULL, NULL}};
		GType my_enum_type_id;
		my_enum_type_id = g_enum_register_static ("MyEnum", values);
		g_once_init_leave (&my_enum_type_id__volatile, my_enum_type_id);
	}
	return my_enum_type_id__volatile;
}


Frodo* frodo_new (gint a) {
	Frodo* self;
	gint _tmp0_ = 0;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	self = g_slice_new0 (Frodo);
	frodo_instance_init (self);
	_tmp0_ = a;
	_tmp1_ = g_strdup_printf ("%i", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("Frodo", _tmp2_, NULL);
	_g_free0 (self->name);
	self->name = _tmp3_;
	_g_free0 (_tmp2_);
	return self;
}


static void frodo_instance_init (Frodo * self) {
}


void frodo_free (Frodo* self) {
	_g_free0 (self->name);
	g_slice_free (Frodo, self);
}


gboolean f1 (gint a) {
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	_tmp0_ = a;
	g_print ("testing delegate value %d\n", _tmp0_);
	result = TRUE;
	return result;
}


void f2 (DelegateType d, void* d_target, gint a) {
	gboolean c = FALSE;
	DelegateType _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	gint _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_ = 0;
	gboolean _tmp4_ = FALSE;
	_tmp0_ = d;
	_tmp0__target = d_target;
	_tmp1_ = a;
	_tmp2_ = _tmp0_ (_tmp1_, _tmp0__target);
	c = _tmp2_;
	_tmp4_ = c;
	if (_tmp4_) {
		_tmp3_ = 1;
	} else {
		_tmp3_ = 0;
	}
	g_print ("c = %d\n", _tmp3_);
}


gchar* fn_no_null (const gchar* param) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (param != NULL, NULL);
	_tmp0_ = param;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


static gboolean _f1_delegate_type (gint a, gpointer self) {
	gboolean result;
	result = f1 (a);
	return result;
}


void _vala_main (gchar** args, int args_length1) {
	StructName mystruct = {0};
	gchar* _tmp0_ = NULL;
	StructName _tmp1_ = {0};
	StructName _tmp2_ = {0};
	gint _tmp3_ = 0;
	Frodo* f = NULL;
	Frodo* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	f2 (_f1_delegate_type, NULL, 5);
	_tmp0_ = g_strdup ("foo");
	memset (&_tmp1_, 0, sizeof (StructName));
	_g_free0 (_tmp1_.a);
	_tmp1_.a = _tmp0_;
	_tmp1_.i = 33;
	mystruct = _tmp1_;
	_tmp2_ = mystruct;
	_tmp3_ = _tmp2_.i;
	g_print ("Hello World %d\n", _tmp3_);
	{
		gint I = 0;
		I = 1;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				if (!_tmp4_) {
					gint _tmp5_ = 0;
					_tmp5_ = I;
					I = _tmp5_ + 1;
				}
				_tmp4_ = FALSE;
				if (!(I <= 10)) {
					break;
				}
				g_print ("looping\n");
			}
		}
	}
	_tmp6_ = frodo_new (42);
	f = _tmp6_;
	_tmp7_ = f->name;
	g_print ("Hello %s\n", _tmp7_);
	_frodo_free0 (f);
	struct_name_destroy (&mystruct);
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	_vala_main (argv, argc);
	return 0;
}



