/* main.c generated by valac 0.34.7, the Vala compiler
 * generated from main.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <float.h>
#include <math.h>

typedef struct _Oops Oops;

#define TYPE_PERSON (person_get_type ())
typedef struct _Person Person;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _oops_free0(var) ((var == NULL) ? NULL : (var = (oops_free (var), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))
#define __g_slist_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_slist_free__g_free0_ (var), NULL)))

typedef enum  {
	MY_ERROR_HAS_FAILED
} MyError;
#define MY_ERROR my_error_quark ()
struct _Oops {
	gint counter;
};

struct _Person {
	gchar* name;
	gint age;
};



GQuark my_error_quark (void);
void oops_free (Oops* self);
static void oops_instance_init (Oops * self);
Oops* oops_new (void);
void oops_fail (Oops* self, GError** error);
void oops_inc (Oops* self);
gchar* oops_to_string (Oops* self);
GType person_get_type (void) G_GNUC_CONST;
Person* person_dup (const Person* self);
void person_free (Person* self);
void person_copy (const Person* self, Person* dest);
void person_destroy (Person* self);
void person_init (Person *self, const gchar* n);
void _vala_main (void);
void test_slist (void);
static void _g_free0_ (gpointer var);
static void _g_list_free__g_free0_ (GList* self);
static void _g_slist_free__g_free0_ (GSList* self);


GQuark my_error_quark (void) {
	return g_quark_from_static_string ("my_error-quark");
}


Oops* oops_new (void) {
	Oops* self;
	self = g_slice_new0 (Oops);
	oops_instance_init (self);
	g_print ("new oops\n");
	self->counter = 0;
	return self;
}


void oops_fail (Oops* self, GError** error) {
	GError* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_error_new_literal (MY_ERROR, MY_ERROR_HAS_FAILED, "calling fail()");
	_inner_error_ = _tmp0_;
	g_propagate_error (error, _inner_error_);
	return;
}


void oops_inc (Oops* self) {
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->counter;
	g_print ("INC %d\n", _tmp0_);
	_tmp1_ = self->counter;
	self->counter = _tmp1_ + 1;
}


gchar* oops_to_string (Oops* self) {
	gchar* result = NULL;
	gint _tmp0_ = 0;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->counter;
	_tmp1_ = g_strdup_printf ("Oops: %d", _tmp0_);
	result = _tmp1_;
	return result;
}


static void oops_instance_init (Oops * self) {
}


void oops_free (Oops* self) {
	g_slice_free (Oops, self);
}


void person_init (Person *self, const gchar* n) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (n != NULL);
	memset (self, 0, sizeof (Person));
	_tmp0_ = n;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*self).name);
	(*self).name = _tmp1_;
	(*self).age = 42;
}


void person_copy (const Person* self, Person* dest) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	_tmp0_ = (*self).name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp1_;
	_tmp2_ = (*self).age;
	(*dest).age = _tmp2_;
}


void person_destroy (Person* self) {
	_g_free0 ((*self).name);
}


Person* person_dup (const Person* self) {
	Person* dup;
	dup = g_new0 (Person, 1);
	person_copy (self, dup);
	return dup;
}


void person_free (Person* self) {
	person_destroy (self);
	g_free (self);
}


GType person_get_type (void) {
	static volatile gsize person_type_id__volatile = 0;
	if (g_once_init_enter (&person_type_id__volatile)) {
		GType person_type_id;
		person_type_id = g_boxed_type_register_static ("Person", (GBoxedCopyFunc) person_dup, (GBoxedFreeFunc) person_free);
		g_once_init_leave (&person_type_id__volatile, person_type_id);
	}
	return person_type_id__volatile;
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


void _vala_main (void) {
	gchar* str = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	Person p = {0};
	FILE* _tmp2_ = NULL;
	Person _tmp3_ = {0};
	const gchar* _tmp4_ = NULL;
	Person _tmp5_ = {0};
	gint _tmp6_ = 0;
	gdouble f = 0.0;
	gdouble _tmp7_ = 0.0;
	Oops* obj = NULL;
	Oops* _tmp12_ = NULL;
	Oops* _tmp20_ = NULL;
	Oops* _tmp21_ = NULL;
	Oops* _tmp22_ = NULL;
	Oops* _tmp23_ = NULL;
	gchar* _tmp24_ = NULL;
	gchar* _tmp25_ = NULL;
	gint* a = NULL;
	gint* _tmp26_ = NULL;
	gint a_length1 = 0;
	gint _a_size_ = 0;
	GList* s = NULL;
	gchar* _tmp44_ = NULL;
	gchar* _tmp45_ = NULL;
	gchar* _tmp46_ = NULL;
	gchar* _tmp47_ = NULL;
	GList* _tmp48_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = g_strdup ("Hello World\n");
	str = _tmp0_;
	_tmp1_ = str;
	g_print ("%s", _tmp1_);
	person_init (&p, "Alice");
	p.age = 42;
	_tmp2_ = stdout;
	_tmp3_ = p;
	_tmp4_ = _tmp3_.name;
	_tmp5_ = p;
	_tmp6_ = _tmp5_.age;
	fprintf (_tmp2_, "  Name: %s\n  Age: %d\n", _tmp4_, _tmp6_);
	f = 2.14;
	_tmp7_ = f;
	g_print ("%f\n", _tmp7_ + 1);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = TRUE;
			while (TRUE) {
				gint _tmp10_ = 0;
				gint _tmp11_ = 0;
				if (!_tmp8_) {
					gint _tmp9_ = 0;
					_tmp9_ = i;
					i = _tmp9_ + 1;
				}
				_tmp8_ = FALSE;
				_tmp10_ = i;
				if (!(_tmp10_ < 3)) {
					break;
				}
				_tmp11_ = i;
				g_print ("Count %d\n", _tmp11_);
			}
		}
	}
	_tmp12_ = oops_new ();
	obj = _tmp12_;
	{
		Oops* _tmp13_ = NULL;
		_tmp13_ = obj;
		oops_fail (_tmp13_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_print ("ERROR FAIL HAS THROWNED EXCEPTICON\n");
		_tmp14_ = e;
		_tmp15_ = _tmp14_->message;
		_tmp16_ = g_strconcat ("message: ", _tmp15_, NULL);
		_tmp17_ = _tmp16_;
		_tmp18_ = g_strconcat (_tmp17_, "\n", NULL);
		_tmp19_ = _tmp18_;
		g_print ("%s", _tmp19_);
		_g_free0 (_tmp19_);
		_g_free0 (_tmp17_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_oops_free0 (obj);
		person_destroy (&p);
		_g_free0 (str);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp20_ = obj;
	oops_inc (_tmp20_);
	_tmp21_ = obj;
	oops_inc (_tmp21_);
	_tmp22_ = obj;
	oops_inc (_tmp22_);
	_tmp23_ = obj;
	_tmp24_ = oops_to_string (_tmp23_);
	_tmp25_ = _tmp24_;
	g_print ("Obj = %s\n", _tmp25_);
	_g_free0 (_tmp25_);
	_oops_free0 (obj);
	obj = NULL;
	_tmp26_ = g_new0 (gint, 10);
	a = _tmp26_;
	a_length1 = 10;
	_a_size_ = a_length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp27_ = FALSE;
			_tmp27_ = TRUE;
			while (TRUE) {
				gint _tmp29_ = 0;
				gint* _tmp30_ = NULL;
				gint _tmp30__length1 = 0;
				gint* _tmp31_ = NULL;
				gint _tmp31__length1 = 0;
				gint _tmp32_ = 0;
				gint _tmp33_ = 0;
				gint _tmp34_ = 0;
				if (!_tmp27_) {
					gint _tmp28_ = 0;
					_tmp28_ = i;
					i = _tmp28_ + 1;
				}
				_tmp27_ = FALSE;
				_tmp29_ = i;
				_tmp30_ = a;
				_tmp30__length1 = a_length1;
				if (!(_tmp29_ < _tmp30__length1)) {
					break;
				}
				_tmp31_ = a;
				_tmp31__length1 = a_length1;
				_tmp32_ = i;
				_tmp33_ = i;
				_tmp31_[_tmp32_] = _tmp33_;
				_tmp34_ = _tmp31_[_tmp32_];
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp35_ = FALSE;
			_tmp35_ = TRUE;
			while (TRUE) {
				gint _tmp37_ = 0;
				gint* _tmp38_ = NULL;
				gint _tmp38__length1 = 0;
				FILE* _tmp39_ = NULL;
				gint _tmp40_ = 0;
				gint* _tmp41_ = NULL;
				gint _tmp41__length1 = 0;
				gint _tmp42_ = 0;
				gint _tmp43_ = 0;
				if (!_tmp35_) {
					gint _tmp36_ = 0;
					_tmp36_ = i;
					i = _tmp36_ + 1;
				}
				_tmp35_ = FALSE;
				_tmp37_ = i;
				_tmp38_ = a;
				_tmp38__length1 = a_length1;
				if (!(_tmp37_ < _tmp38__length1)) {
					break;
				}
				_tmp39_ = stderr;
				_tmp40_ = i;
				_tmp41_ = a;
				_tmp41__length1 = a_length1;
				_tmp42_ = i;
				_tmp43_ = _tmp41_[_tmp42_];
				fprintf (_tmp39_, "--> %d %d\n", _tmp40_, _tmp43_);
			}
		}
	}
	s = NULL;
	_tmp44_ = g_strdup ("pop");
	s = g_list_append (s, _tmp44_);
	_tmp45_ = g_strdup ("jojo");
	s = g_list_append (s, _tmp45_);
	_tmp46_ = g_strdup ("lalla");
	s = g_list_append (s, _tmp46_);
	_tmp47_ = g_strdup ("FIRST");
	s = g_list_prepend (s, _tmp47_);
	_tmp48_ = s;
	{
		GList* z_collection = NULL;
		GList* z_it = NULL;
		z_collection = _tmp48_;
		for (z_it = z_collection; z_it != NULL; z_it = z_it->next) {
			gchar* _tmp49_ = NULL;
			gchar* z = NULL;
			_tmp49_ = g_strdup ((const gchar*) z_it->data);
			z = _tmp49_;
			{
				const gchar* _tmp50_ = NULL;
				gchar* _tmp51_ = NULL;
				gchar* _tmp52_ = NULL;
				gchar* _tmp53_ = NULL;
				gchar* _tmp54_ = NULL;
				_tmp50_ = z;
				_tmp51_ = g_strconcat ("strings : ", _tmp50_, NULL);
				_tmp52_ = _tmp51_;
				_tmp53_ = g_strconcat (_tmp52_, "\n", NULL);
				_tmp54_ = _tmp53_;
				g_print ("%s", _tmp54_);
				_g_free0 (_tmp54_);
				_g_free0 (_tmp52_);
				_g_free0 (z);
			}
		}
	}
	test_slist ();
	__g_list_free__g_free0_0 (s);
	a = (g_free (a), NULL);
	_oops_free0 (obj);
	person_destroy (&p);
	_g_free0 (str);
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	_vala_main ();
	return 0;
}


static void _g_slist_free__g_free0_ (GSList* self) {
	g_slist_foreach (self, (GFunc) _g_free0_, NULL);
	g_slist_free (self);
}


void test_slist (void) {
	GSList* s = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	GSList* _tmp4_ = NULL;
	s = NULL;
	_tmp0_ = g_strdup ("pop");
	s = g_slist_append (s, _tmp0_);
	_tmp1_ = g_strdup ("jojo");
	s = g_slist_append (s, _tmp1_);
	_tmp2_ = g_strdup ("lalla");
	s = g_slist_append (s, _tmp2_);
	_tmp3_ = g_strdup ("FIRST");
	s = g_slist_prepend (s, _tmp3_);
	_tmp4_ = s;
	{
		GSList* z_collection = NULL;
		GSList* z_it = NULL;
		z_collection = _tmp4_;
		for (z_it = z_collection; z_it != NULL; z_it = z_it->next) {
			gchar* _tmp5_ = NULL;
			gchar* z = NULL;
			_tmp5_ = g_strdup ((const gchar*) z_it->data);
			z = _tmp5_;
			{
				const gchar* _tmp6_ = NULL;
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				gchar* _tmp10_ = NULL;
				_tmp6_ = z;
				_tmp7_ = g_strconcat ("strings : ", _tmp6_, NULL);
				_tmp8_ = _tmp7_;
				_tmp9_ = g_strconcat (_tmp8_, "\n", NULL);
				_tmp10_ = _tmp9_;
				g_print ("%s", _tmp10_);
				_g_free0 (_tmp10_);
				_g_free0 (_tmp8_);
				_g_free0 (z);
			}
		}
	}
	__g_slist_free__g_free0_0 (s);
}



